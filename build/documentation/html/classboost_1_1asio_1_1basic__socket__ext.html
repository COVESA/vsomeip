<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vsomeip-3.1.20: boost::asio::basic_socket_ext&lt; BOOST_ASIO_SVC_TPARAM &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">vsomeip-3.1.20
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classboost_1_1asio_1_1basic__socket__ext.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classboost_1_1asio_1_1basic__socket__ext-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">boost::asio::basic_socket_ext&lt; BOOST_ASIO_SVC_TPARAM &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides socket functionality.  
 <a href="classboost_1_1asio_1_1basic__socket__ext.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for boost::asio::basic_socket_ext&lt; BOOST_ASIO_SVC_TPARAM &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classboost_1_1asio_1_1basic__socket__ext__inherit__graph.svg" width="382" height="171"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for boost::asio::basic_socket_ext&lt; BOOST_ASIO_SVC_TPARAM &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classboost_1_1asio_1_1basic__socket__ext__coll__graph.svg" width="382" height="171"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1asio_1_1basic__socket__ext_1_1rebind__executor.html">rebind_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebinds the socket type to another executor.  <a href="structboost_1_1asio_1_1basic__socket__ext_1_1rebind__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a42d4321011c94952dcbc675ed7360870"><td class="memItemLeft" align="right" valign="top">typedef io_context::executor_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a></td></tr>
<tr class="memdesc:a42d4321011c94952dcbc675ed7360870"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">More...</a><br /></td></tr>
<tr class="separator:a42d4321011c94952dcbc675ed7360870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7745ea4769db54c740f43a0c6a17dec6"><td class="memItemLeft" align="right" valign="top">typedef BOOST_ASIO_SVC_T::native_handle_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a></td></tr>
<tr class="memdesc:a7745ea4769db54c740f43a0c6a17dec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The native representation of a socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">More...</a><br /></td></tr>
<tr class="separator:a7745ea4769db54c740f43a0c6a17dec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5989efa6b723759fc9c2f1597d2dfa7f"><td class="memItemLeft" align="right" valign="top">typedef Protocol&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a></td></tr>
<tr class="memdesc:a5989efa6b723759fc9c2f1597d2dfa7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protocol type.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">More...</a><br /></td></tr>
<tr class="separator:a5989efa6b723759fc9c2f1597d2dfa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9a01a2659abf8a5acafa431763772d"><td class="memItemLeft" align="right" valign="top">typedef Protocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a></td></tr>
<tr class="memdesc:aab9a01a2659abf8a5acafa431763772d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endpoint type.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">More...</a><br /></td></tr>
<tr class="separator:aab9a01a2659abf8a5acafa431763772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a96cb52d5b515905dd6ef052134209e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a>&lt; Protocol BOOST_ASIO_SVC_TARG &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a></td></tr>
<tr class="memdesc:a9a96cb52d5b515905dd6ef052134209e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic_socket is always the lowest layer.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">More...</a><br /></td></tr>
<tr class="separator:a9a96cb52d5b515905dd6ef052134209e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c93e86433026ca37402a17ea580f212"><td class="memItemLeft" align="right" valign="top">typedef Executor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a4c93e86433026ca37402a17ea580f212">executor_type</a></td></tr>
<tr class="memdesc:a4c93e86433026ca37402a17ea580f212"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a4c93e86433026ca37402a17ea580f212">More...</a><br /></td></tr>
<tr class="separator:a4c93e86433026ca37402a17ea580f212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0872e36afce4710f2709a2b5151e597"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classboost_1_1asio_1_1detail_1_1reactive__socket__service__ext.html">detail::reactive_socket_service_ext</a>&lt; Protocol &gt;::native_handle_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab0872e36afce4710f2709a2b5151e597">native_handle_type</a></td></tr>
<tr class="memdesc:ab0872e36afce4710f2709a2b5151e597"><td class="mdescLeft">&#160;</td><td class="mdescRight">The native representation of a socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab0872e36afce4710f2709a2b5151e597">More...</a><br /></td></tr>
<tr class="separator:ab0872e36afce4710f2709a2b5151e597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5989efa6b723759fc9c2f1597d2dfa7f"><td class="memItemLeft" align="right" valign="top">typedef Protocol&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a></td></tr>
<tr class="memdesc:a5989efa6b723759fc9c2f1597d2dfa7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protocol type.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">More...</a><br /></td></tr>
<tr class="separator:a5989efa6b723759fc9c2f1597d2dfa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9a01a2659abf8a5acafa431763772d"><td class="memItemLeft" align="right" valign="top">typedef Protocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a></td></tr>
<tr class="memdesc:aab9a01a2659abf8a5acafa431763772d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endpoint type.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">More...</a><br /></td></tr>
<tr class="separator:aab9a01a2659abf8a5acafa431763772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab335d2eeee25424657e91a7fb4f58ea3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a>&lt; Protocol, Executor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab335d2eeee25424657e91a7fb4f58ea3">lowest_layer_type</a></td></tr>
<tr class="memdesc:ab335d2eeee25424657e91a7fb4f58ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic_socket is always the lowest layer.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab335d2eeee25424657e91a7fb4f58ea3">More...</a><br /></td></tr>
<tr class="separator:ab335d2eeee25424657e91a7fb4f58ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c93e86433026ca37402a17ea580f212"><td class="memItemLeft" align="right" valign="top">typedef Executor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a4c93e86433026ca37402a17ea580f212">executor_type</a></td></tr>
<tr class="memdesc:a4c93e86433026ca37402a17ea580f212"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a4c93e86433026ca37402a17ea580f212">More...</a><br /></td></tr>
<tr class="separator:a4c93e86433026ca37402a17ea580f212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0872e36afce4710f2709a2b5151e597"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classboost_1_1asio_1_1detail_1_1reactive__socket__service__ext.html">detail::reactive_socket_service_ext</a>&lt; Protocol &gt;::native_handle_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab0872e36afce4710f2709a2b5151e597">native_handle_type</a></td></tr>
<tr class="memdesc:ab0872e36afce4710f2709a2b5151e597"><td class="mdescLeft">&#160;</td><td class="mdescRight">The native representation of a socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab0872e36afce4710f2709a2b5151e597">More...</a><br /></td></tr>
<tr class="separator:ab0872e36afce4710f2709a2b5151e597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5989efa6b723759fc9c2f1597d2dfa7f"><td class="memItemLeft" align="right" valign="top">typedef Protocol&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a></td></tr>
<tr class="memdesc:a5989efa6b723759fc9c2f1597d2dfa7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protocol type.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">More...</a><br /></td></tr>
<tr class="separator:a5989efa6b723759fc9c2f1597d2dfa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9a01a2659abf8a5acafa431763772d"><td class="memItemLeft" align="right" valign="top">typedef Protocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a></td></tr>
<tr class="memdesc:aab9a01a2659abf8a5acafa431763772d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endpoint type.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">More...</a><br /></td></tr>
<tr class="separator:aab9a01a2659abf8a5acafa431763772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab335d2eeee25424657e91a7fb4f58ea3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a>&lt; Protocol, Executor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab335d2eeee25424657e91a7fb4f58ea3">lowest_layer_type</a></td></tr>
<tr class="memdesc:ab335d2eeee25424657e91a7fb4f58ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic_socket is always the lowest layer.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab335d2eeee25424657e91a7fb4f58ea3">More...</a><br /></td></tr>
<tr class="separator:ab335d2eeee25424657e91a7fb4f58ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c93e86433026ca37402a17ea580f212"><td class="memItemLeft" align="right" valign="top">typedef Executor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a4c93e86433026ca37402a17ea580f212">executor_type</a></td></tr>
<tr class="memdesc:a4c93e86433026ca37402a17ea580f212"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a4c93e86433026ca37402a17ea580f212">More...</a><br /></td></tr>
<tr class="separator:a4c93e86433026ca37402a17ea580f212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0872e36afce4710f2709a2b5151e597"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classboost_1_1asio_1_1detail_1_1reactive__socket__service__ext.html">detail::reactive_socket_service_ext</a>&lt; Protocol &gt;::native_handle_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab0872e36afce4710f2709a2b5151e597">native_handle_type</a></td></tr>
<tr class="memdesc:ab0872e36afce4710f2709a2b5151e597"><td class="mdescLeft">&#160;</td><td class="mdescRight">The native representation of a socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab0872e36afce4710f2709a2b5151e597">More...</a><br /></td></tr>
<tr class="separator:ab0872e36afce4710f2709a2b5151e597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5989efa6b723759fc9c2f1597d2dfa7f"><td class="memItemLeft" align="right" valign="top">typedef Protocol&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a></td></tr>
<tr class="memdesc:a5989efa6b723759fc9c2f1597d2dfa7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protocol type.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">More...</a><br /></td></tr>
<tr class="separator:a5989efa6b723759fc9c2f1597d2dfa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9a01a2659abf8a5acafa431763772d"><td class="memItemLeft" align="right" valign="top">typedef Protocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a></td></tr>
<tr class="memdesc:aab9a01a2659abf8a5acafa431763772d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endpoint type.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">More...</a><br /></td></tr>
<tr class="separator:aab9a01a2659abf8a5acafa431763772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab335d2eeee25424657e91a7fb4f58ea3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a>&lt; Protocol, Executor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab335d2eeee25424657e91a7fb4f58ea3">lowest_layer_type</a></td></tr>
<tr class="memdesc:ab335d2eeee25424657e91a7fb4f58ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A basic_socket is always the lowest layer.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab335d2eeee25424657e91a7fb4f58ea3">More...</a><br /></td></tr>
<tr class="separator:ab335d2eeee25424657e91a7fb4f58ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adeb1298a522bb63512a2b802b3e1907e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#adeb1298a522bb63512a2b802b3e1907e">basic_socket_ext</a> (boost::asio::io_context &amp;io_context)</td></tr>
<tr class="memdesc:adeb1298a522bb63512a2b802b3e1907e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket without opening it.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#adeb1298a522bb63512a2b802b3e1907e">More...</a><br /></td></tr>
<tr class="separator:adeb1298a522bb63512a2b802b3e1907e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b500569fe6f8405ad6201592072b898"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a2b500569fe6f8405ad6201592072b898">basic_socket_ext</a> (boost::asio::io_context &amp;io_context, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol)</td></tr>
<tr class="memdesc:a2b500569fe6f8405ad6201592072b898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and open a basic_socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a2b500569fe6f8405ad6201592072b898">More...</a><br /></td></tr>
<tr class="separator:a2b500569fe6f8405ad6201592072b898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819d7360312f50f77288f45d9f746ec5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a819d7360312f50f77288f45d9f746ec5">basic_socket_ext</a> (boost::asio::io_context &amp;io_context, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint)</td></tr>
<tr class="separator:a819d7360312f50f77288f45d9f746ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5ab4ee51d3c93e8cc67cbd55fc8f55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a5ab4ee51d3c93e8cc67cbd55fc8f55">basic_socket_ext</a> (boost::asio::io_context &amp;io_context, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket)</td></tr>
<tr class="memdesc:a9a5ab4ee51d3c93e8cc67cbd55fc8f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket on an existing native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a9a5ab4ee51d3c93e8cc67cbd55fc8f55">More...</a><br /></td></tr>
<tr class="separator:a9a5ab4ee51d3c93e8cc67cbd55fc8f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb81a8ec76021ed1c1e443bf373f628b"><td class="memItemLeft" align="right" valign="top">boost::asio::io_context &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afb81a8ec76021ed1c1e443bf373f628b">get_io_context</a> ()</td></tr>
<tr class="separator:afb81a8ec76021ed1c1e443bf373f628b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af968f55f9111335061353ee3ba2c7f3a"><td class="memItemLeft" align="right" valign="top">boost::asio::io_context &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#af968f55f9111335061353ee3ba2c7f3a">get_io_service</a> ()</td></tr>
<tr class="separator:af968f55f9111335061353ee3ba2c7f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ac2e0a04f3d9093085c831cd1b2e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a95ac2e0a04f3d9093085c831cd1b2e89">get_executor</a> () BOOST_ASIO_NOEXCEPT</td></tr>
<tr class="memdesc:a95ac2e0a04f3d9093085c831cd1b2e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor associated with the object.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a95ac2e0a04f3d9093085c831cd1b2e89">More...</a><br /></td></tr>
<tr class="separator:a95ac2e0a04f3d9093085c831cd1b2e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f770d36ec3d719d3336670bdb2183e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a1f770d36ec3d719d3336670bdb2183e0">lowest_layer</a> ()</td></tr>
<tr class="memdesc:a1f770d36ec3d719d3336670bdb2183e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a1f770d36ec3d719d3336670bdb2183e0">More...</a><br /></td></tr>
<tr class="separator:a1f770d36ec3d719d3336670bdb2183e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26ce5761a57a4179b98858b7853623c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac26ce5761a57a4179b98858b7853623c">lowest_layer</a> () const</td></tr>
<tr class="memdesc:ac26ce5761a57a4179b98858b7853623c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the lowest layer.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac26ce5761a57a4179b98858b7853623c">More...</a><br /></td></tr>
<tr class="separator:ac26ce5761a57a4179b98858b7853623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26576c8e6d36e76747d1b780b6196b37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a26576c8e6d36e76747d1b780b6196b37">open</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol=<a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a>())</td></tr>
<tr class="memdesc:a26576c8e6d36e76747d1b780b6196b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a26576c8e6d36e76747d1b780b6196b37">More...</a><br /></td></tr>
<tr class="separator:a26576c8e6d36e76747d1b780b6196b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b206ea012bc0a77a9c71d139699083f"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5b206ea012bc0a77a9c71d139699083f">open</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a5b206ea012bc0a77a9c71d139699083f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a5b206ea012bc0a77a9c71d139699083f">More...</a><br /></td></tr>
<tr class="separator:a5b206ea012bc0a77a9c71d139699083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6535d1b89c7b1c5492be594a72e22d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac6535d1b89c7b1c5492be594a72e22d8">assign</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket)</td></tr>
<tr class="memdesc:ac6535d1b89c7b1c5492be594a72e22d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an existing native socket to the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac6535d1b89c7b1c5492be594a72e22d8">More...</a><br /></td></tr>
<tr class="separator:ac6535d1b89c7b1c5492be594a72e22d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8a2175a4afbdcbd5ded9041e1fb15d"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3d8a2175a4afbdcbd5ded9041e1fb15d">assign</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a3d8a2175a4afbdcbd5ded9041e1fb15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an existing native socket to the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a3d8a2175a4afbdcbd5ded9041e1fb15d">More...</a><br /></td></tr>
<tr class="separator:a3d8a2175a4afbdcbd5ded9041e1fb15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fb6eacd32dd56f928e3e90e6bb7b24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a69fb6eacd32dd56f928e3e90e6bb7b24">is_open</a> () const</td></tr>
<tr class="memdesc:a69fb6eacd32dd56f928e3e90e6bb7b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the socket is open.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a69fb6eacd32dd56f928e3e90e6bb7b24">More...</a><br /></td></tr>
<tr class="separator:a69fb6eacd32dd56f928e3e90e6bb7b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdce8530339e4ec98dd5120510282204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204">close</a> ()</td></tr>
<tr class="memdesc:afdce8530339e4ec98dd5120510282204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204">More...</a><br /></td></tr>
<tr class="separator:afdce8530339e4ec98dd5120510282204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af919511c29149305b1ab24e920458733"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#af919511c29149305b1ab24e920458733">close</a> (boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:af919511c29149305b1ab24e920458733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#af919511c29149305b1ab24e920458733">More...</a><br /></td></tr>
<tr class="separator:af919511c29149305b1ab24e920458733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227b2204377ed42af6a9a6f4ca413a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a227b2204377ed42af6a9a6f4ca413a72">release</a> ()</td></tr>
<tr class="memdesc:a227b2204377ed42af6a9a6f4ca413a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of the underlying native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a227b2204377ed42af6a9a6f4ca413a72">More...</a><br /></td></tr>
<tr class="separator:a227b2204377ed42af6a9a6f4ca413a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea481ad3c0b5ec252c560aa032a20a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aea481ad3c0b5ec252c560aa032a20a67">release</a> (boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:aea481ad3c0b5ec252c560aa032a20a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of the underlying native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aea481ad3c0b5ec252c560aa032a20a67">More...</a><br /></td></tr>
<tr class="separator:aea481ad3c0b5ec252c560aa032a20a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2255ad070b1a41ea9e98634a6b2c4df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a2255ad070b1a41ea9e98634a6b2c4df9">native_handle</a> ()</td></tr>
<tr class="memdesc:a2255ad070b1a41ea9e98634a6b2c4df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the native socket representation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a2255ad070b1a41ea9e98634a6b2c4df9">More...</a><br /></td></tr>
<tr class="separator:a2255ad070b1a41ea9e98634a6b2c4df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a83976853db16f08ba074b926b3bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb">cancel</a> ()</td></tr>
<tr class="memdesc:a52a83976853db16f08ba074b926b3bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all asynchronous operations associated with the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb">More...</a><br /></td></tr>
<tr class="separator:a52a83976853db16f08ba074b926b3bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911721f6fec972f23a31190c4cec228c"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a911721f6fec972f23a31190c4cec228c">cancel</a> (boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a911721f6fec972f23a31190c4cec228c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all asynchronous operations associated with the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a911721f6fec972f23a31190c4cec228c">More...</a><br /></td></tr>
<tr class="separator:a911721f6fec972f23a31190c4cec228c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f99ae2d36c9827b09eb8e002240be70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a1f99ae2d36c9827b09eb8e002240be70">at_mark</a> () const</td></tr>
<tr class="memdesc:a1f99ae2d36c9827b09eb8e002240be70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the socket is at the out-of-band data mark.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a1f99ae2d36c9827b09eb8e002240be70">More...</a><br /></td></tr>
<tr class="separator:a1f99ae2d36c9827b09eb8e002240be70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1608bd9a1e1b878fb54e7604247d3ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ad1608bd9a1e1b878fb54e7604247d3ea">at_mark</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:ad1608bd9a1e1b878fb54e7604247d3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the socket is at the out-of-band data mark.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ad1608bd9a1e1b878fb54e7604247d3ea">More...</a><br /></td></tr>
<tr class="separator:ad1608bd9a1e1b878fb54e7604247d3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130284ccf15b2dcc67b17bdbb23f9de1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a130284ccf15b2dcc67b17bdbb23f9de1">available</a> () const</td></tr>
<tr class="memdesc:a130284ccf15b2dcc67b17bdbb23f9de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the number of bytes available for reading.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a130284ccf15b2dcc67b17bdbb23f9de1">More...</a><br /></td></tr>
<tr class="separator:a130284ccf15b2dcc67b17bdbb23f9de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892c95c3645a159f94e133431317e416"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a892c95c3645a159f94e133431317e416">available</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:a892c95c3645a159f94e133431317e416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the number of bytes available for reading.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a892c95c3645a159f94e133431317e416">More...</a><br /></td></tr>
<tr class="separator:a892c95c3645a159f94e133431317e416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cf567fa998b998bd2982c079a4cdba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a25cf567fa998b998bd2982c079a4cdba">bind</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint)</td></tr>
<tr class="memdesc:a25cf567fa998b998bd2982c079a4cdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a25cf567fa998b998bd2982c079a4cdba">More...</a><br /></td></tr>
<tr class="separator:a25cf567fa998b998bd2982c079a4cdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6849b1ba5787b8a8c8558b193480a7e9"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a6849b1ba5787b8a8c8558b193480a7e9">bind</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a6849b1ba5787b8a8c8558b193480a7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a6849b1ba5787b8a8c8558b193480a7e9">More...</a><br /></td></tr>
<tr class="separator:a6849b1ba5787b8a8c8558b193480a7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b82003a1cae324ecedeff6faeee217"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a48b82003a1cae324ecedeff6faeee217">connect</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;peer_endpoint)</td></tr>
<tr class="memdesc:a48b82003a1cae324ecedeff6faeee217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the socket to the specified endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a48b82003a1cae324ecedeff6faeee217">More...</a><br /></td></tr>
<tr class="separator:a48b82003a1cae324ecedeff6faeee217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdf6919cf1d64a43123ffd301872bfa"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0cdf6919cf1d64a43123ffd301872bfa">connect</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;peer_endpoint, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a0cdf6919cf1d64a43123ffd301872bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the socket to the specified endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a0cdf6919cf1d64a43123ffd301872bfa">More...</a><br /></td></tr>
<tr class="separator:a0cdf6919cf1d64a43123ffd301872bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4995b5fb481520b3d7b312da5e04b2a9"><td class="memTemplParams" colspan="2">template&lt;typename ConnectHandler &gt; </td></tr>
<tr class="memitem:a4995b5fb481520b3d7b312da5e04b2a9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a4995b5fb481520b3d7b312da5e04b2a9">BOOST_ASIO_INITFN_RESULT_TYPE</a> (ConnectHandler, void(boost::system::error_code)) async_connect(const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;peer_endpoint</td></tr>
<tr class="memdesc:a4995b5fb481520b3d7b312da5e04b2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous connect.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a4995b5fb481520b3d7b312da5e04b2a9">More...</a><br /></td></tr>
<tr class="separator:a4995b5fb481520b3d7b312da5e04b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07690df72c82afeca1e1da0293bce840"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a07690df72c82afeca1e1da0293bce840">BOOST_ASIO_MOVE_ARG</a> (ConnectHandler) handler)</td></tr>
<tr class="separator:a07690df72c82afeca1e1da0293bce840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a7300fb93369d191e10c30e9910cb7"><td class="memTemplParams" colspan="2">template&lt;typename SettableSocketOption &gt; </td></tr>
<tr class="memitem:aa8a7300fb93369d191e10c30e9910cb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa8a7300fb93369d191e10c30e9910cb7">set_option</a> (const SettableSocketOption &amp;option)</td></tr>
<tr class="memdesc:aa8a7300fb93369d191e10c30e9910cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aa8a7300fb93369d191e10c30e9910cb7">More...</a><br /></td></tr>
<tr class="separator:aa8a7300fb93369d191e10c30e9910cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec41185f85b3ead8586d4158ab4784d1"><td class="memTemplParams" colspan="2">template&lt;typename SettableSocketOption &gt; </td></tr>
<tr class="memitem:aec41185f85b3ead8586d4158ab4784d1"><td class="memTemplItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aec41185f85b3ead8586d4158ab4784d1">set_option</a> (const SettableSocketOption &amp;option, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:aec41185f85b3ead8586d4158ab4784d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aec41185f85b3ead8586d4158ab4784d1">More...</a><br /></td></tr>
<tr class="separator:aec41185f85b3ead8586d4158ab4784d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce9d93dad74f9d8c3754105616b8c61"><td class="memTemplParams" colspan="2">template&lt;typename GettableSocketOption &gt; </td></tr>
<tr class="memitem:a6ce9d93dad74f9d8c3754105616b8c61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a6ce9d93dad74f9d8c3754105616b8c61">get_option</a> (GettableSocketOption &amp;option) const</td></tr>
<tr class="memdesc:a6ce9d93dad74f9d8c3754105616b8c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an option from the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a6ce9d93dad74f9d8c3754105616b8c61">More...</a><br /></td></tr>
<tr class="separator:a6ce9d93dad74f9d8c3754105616b8c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abb98d4a8856876cad0eb2cf2420799"><td class="memTemplParams" colspan="2">template&lt;typename GettableSocketOption &gt; </td></tr>
<tr class="memitem:a0abb98d4a8856876cad0eb2cf2420799"><td class="memTemplItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0abb98d4a8856876cad0eb2cf2420799">get_option</a> (GettableSocketOption &amp;option, boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:a0abb98d4a8856876cad0eb2cf2420799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an option from the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a0abb98d4a8856876cad0eb2cf2420799">More...</a><br /></td></tr>
<tr class="separator:a0abb98d4a8856876cad0eb2cf2420799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="memTemplParams" colspan="2">template&lt;typename IoControlCommand &gt; </td></tr>
<tr class="memitem:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac1b9c5f9b19f0f415e51cef3360953c8">io_control</a> (IoControlCommand &amp;command)</td></tr>
<tr class="memdesc:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac1b9c5f9b19f0f415e51cef3360953c8">More...</a><br /></td></tr>
<tr class="separator:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f422520c4bd3f9e41bfa576c5050dc"><td class="memTemplParams" colspan="2">template&lt;typename IoControlCommand &gt; </td></tr>
<tr class="memitem:a40f422520c4bd3f9e41bfa576c5050dc"><td class="memTemplItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a40f422520c4bd3f9e41bfa576c5050dc">io_control</a> (IoControlCommand &amp;command, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a40f422520c4bd3f9e41bfa576c5050dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a40f422520c4bd3f9e41bfa576c5050dc">More...</a><br /></td></tr>
<tr class="separator:a40f422520c4bd3f9e41bfa576c5050dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5583879f72ebbabf7cba6db1d53e05b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6">non_blocking</a> () const</td></tr>
<tr class="memdesc:a5583879f72ebbabf7cba6db1d53e05b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the non-blocking mode of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6">More...</a><br /></td></tr>
<tr class="separator:a5583879f72ebbabf7cba6db1d53e05b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cb97246819ca03b004303a36215a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab8cb97246819ca03b004303a36215a22">non_blocking</a> (bool mode)</td></tr>
<tr class="memdesc:ab8cb97246819ca03b004303a36215a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab8cb97246819ca03b004303a36215a22">More...</a><br /></td></tr>
<tr class="separator:ab8cb97246819ca03b004303a36215a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af847fa0d78fc4c63edfe85e0da0fa416"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#af847fa0d78fc4c63edfe85e0da0fa416">non_blocking</a> (bool mode, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:af847fa0d78fc4c63edfe85e0da0fa416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#af847fa0d78fc4c63edfe85e0da0fa416">More...</a><br /></td></tr>
<tr class="separator:af847fa0d78fc4c63edfe85e0da0fa416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13f6bf25a6ecc6a12a1ece32c0c5155"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ae13f6bf25a6ecc6a12a1ece32c0c5155">native_non_blocking</a> () const</td></tr>
<tr class="memdesc:ae13f6bf25a6ecc6a12a1ece32c0c5155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the non-blocking mode of the native socket implementation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ae13f6bf25a6ecc6a12a1ece32c0c5155">More...</a><br /></td></tr>
<tr class="separator:ae13f6bf25a6ecc6a12a1ece32c0c5155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab2d02c9fe5c70adc0cd64acee0c505"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a6ab2d02c9fe5c70adc0cd64acee0c505">native_non_blocking</a> (bool mode)</td></tr>
<tr class="memdesc:a6ab2d02c9fe5c70adc0cd64acee0c505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the native socket implementation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a6ab2d02c9fe5c70adc0cd64acee0c505">More...</a><br /></td></tr>
<tr class="separator:a6ab2d02c9fe5c70adc0cd64acee0c505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440a334c97758148d69593027ee086a0"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a440a334c97758148d69593027ee086a0">native_non_blocking</a> (bool mode, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a440a334c97758148d69593027ee086a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the native socket implementation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a440a334c97758148d69593027ee086a0">More...</a><br /></td></tr>
<tr class="separator:a440a334c97758148d69593027ee086a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16392c0e6de7bc65b64ad518e336af0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa16392c0e6de7bc65b64ad518e336af0">local_endpoint</a> () const</td></tr>
<tr class="memdesc:aa16392c0e6de7bc65b64ad518e336af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aa16392c0e6de7bc65b64ad518e336af0">More...</a><br /></td></tr>
<tr class="separator:aa16392c0e6de7bc65b64ad518e336af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0331784d0776292184d63e87693784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aae0331784d0776292184d63e87693784">local_endpoint</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:aae0331784d0776292184d63e87693784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aae0331784d0776292184d63e87693784">More...</a><br /></td></tr>
<tr class="separator:aae0331784d0776292184d63e87693784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe814bdd7411657702a1b53e833b456a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afe814bdd7411657702a1b53e833b456a">remote_endpoint</a> () const</td></tr>
<tr class="memdesc:afe814bdd7411657702a1b53e833b456a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#afe814bdd7411657702a1b53e833b456a">More...</a><br /></td></tr>
<tr class="separator:afe814bdd7411657702a1b53e833b456a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac098a6653e8f75b97ac5d43b13032db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac098a6653e8f75b97ac5d43b13032db9">remote_endpoint</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:ac098a6653e8f75b97ac5d43b13032db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac098a6653e8f75b97ac5d43b13032db9">More...</a><br /></td></tr>
<tr class="separator:ac098a6653e8f75b97ac5d43b13032db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b63df8c121779b9397f34ba04666a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36">shutdown</a> (shutdown_type what)</td></tr>
<tr class="memdesc:a3b63df8c121779b9397f34ba04666a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36">More...</a><br /></td></tr>
<tr class="separator:a3b63df8c121779b9397f34ba04666a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8299c1f15b32b3f43882eb00aa7ba57"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab8299c1f15b32b3f43882eb00aa7ba57">shutdown</a> (shutdown_type what, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:ab8299c1f15b32b3f43882eb00aa7ba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab8299c1f15b32b3f43882eb00aa7ba57">More...</a><br /></td></tr>
<tr class="separator:ab8299c1f15b32b3f43882eb00aa7ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe4c776eafd6ae48e36cc1a39f46f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0fe4c776eafd6ae48e36cc1a39f46f86">wait</a> (wait_type w)</td></tr>
<tr class="separator:a0fe4c776eafd6ae48e36cc1a39f46f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47272c53e40f0a466ec2901d078f054"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa47272c53e40f0a466ec2901d078f054">wait</a> (wait_type w, boost::system::error_code &amp;ec)</td></tr>
<tr class="separator:aa47272c53e40f0a466ec2901d078f054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57721ab2c488aec20ebf45e4c33bb4b"><td class="memTemplParams" colspan="2">template&lt;typename WaitHandler &gt; </td></tr>
<tr class="memitem:aa57721ab2c488aec20ebf45e4c33bb4b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa57721ab2c488aec20ebf45e4c33bb4b">BOOST_ASIO_INITFN_RESULT_TYPE</a> (WaitHandler, void(boost::system::error_code)) async_wait(wait_type w</td></tr>
<tr class="separator:aa57721ab2c488aec20ebf45e4c33bb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adace1cef903348394af07dbd8b3a58a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#adace1cef903348394af07dbd8b3a58a7">BOOST_ASIO_MOVE_ARG</a> (WaitHandler) handler)</td></tr>
<tr class="separator:adace1cef903348394af07dbd8b3a58a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af688355eaa54b356b7ab8df9ba52368f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#af688355eaa54b356b7ab8df9ba52368f">basic_socket_ext</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;ex)</td></tr>
<tr class="memdesc:af688355eaa54b356b7ab8df9ba52368f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket without opening it.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#af688355eaa54b356b7ab8df9ba52368f">More...</a><br /></td></tr>
<tr class="separator:af688355eaa54b356b7ab8df9ba52368f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64332a2fed132f8536f361b8130f44f"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:ad64332a2fed132f8536f361b8130f44f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ad64332a2fed132f8536f361b8130f44f">basic_socket_ext</a> (ExecutionContext &amp;context, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ad64332a2fed132f8536f361b8130f44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket without opening it.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ad64332a2fed132f8536f361b8130f44f">More...</a><br /></td></tr>
<tr class="separator:ad64332a2fed132f8536f361b8130f44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada058fd47609108e17ee9907395acf56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ada058fd47609108e17ee9907395acf56">basic_socket_ext</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;ex, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol)</td></tr>
<tr class="memdesc:ada058fd47609108e17ee9907395acf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and open a basic_socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ada058fd47609108e17ee9907395acf56">More...</a><br /></td></tr>
<tr class="separator:ada058fd47609108e17ee9907395acf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09fd4866cf6478e742bd45f29d9257d"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:ad09fd4866cf6478e742bd45f29d9257d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ad09fd4866cf6478e742bd45f29d9257d">basic_socket_ext</a> (ExecutionContext &amp;context, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ad09fd4866cf6478e742bd45f29d9257d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and open a basic_socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ad09fd4866cf6478e742bd45f29d9257d">More...</a><br /></td></tr>
<tr class="separator:ad09fd4866cf6478e742bd45f29d9257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fec3d3599818343f3890e238a8ca360"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9fec3d3599818343f3890e238a8ca360">basic_socket_ext</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;ex, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint)</td></tr>
<tr class="separator:a9fec3d3599818343f3890e238a8ca360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e636c02cf8c050c1814ea0061271547"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a0e636c02cf8c050c1814ea0061271547"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0e636c02cf8c050c1814ea0061271547">basic_socket_ext</a> (ExecutionContext &amp;context, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:a0e636c02cf8c050c1814ea0061271547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bbe46f4d81495748834603adcfc37c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a57bbe46f4d81495748834603adcfc37c">basic_socket_ext</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;ex, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket)</td></tr>
<tr class="memdesc:a57bbe46f4d81495748834603adcfc37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket on an existing native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a57bbe46f4d81495748834603adcfc37c">More...</a><br /></td></tr>
<tr class="separator:a57bbe46f4d81495748834603adcfc37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b33aa241e122e3df6a53783effe266"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a01b33aa241e122e3df6a53783effe266"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a01b33aa241e122e3df6a53783effe266">basic_socket_ext</a> (ExecutionContext &amp;context, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a01b33aa241e122e3df6a53783effe266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket on an existing native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a01b33aa241e122e3df6a53783effe266">More...</a><br /></td></tr>
<tr class="separator:a01b33aa241e122e3df6a53783effe266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ac2e0a04f3d9093085c831cd1b2e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a95ac2e0a04f3d9093085c831cd1b2e89">get_executor</a> () BOOST_ASIO_NOEXCEPT</td></tr>
<tr class="memdesc:a95ac2e0a04f3d9093085c831cd1b2e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor associated with the object.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a95ac2e0a04f3d9093085c831cd1b2e89">More...</a><br /></td></tr>
<tr class="separator:a95ac2e0a04f3d9093085c831cd1b2e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f770d36ec3d719d3336670bdb2183e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a1f770d36ec3d719d3336670bdb2183e0">lowest_layer</a> ()</td></tr>
<tr class="memdesc:a1f770d36ec3d719d3336670bdb2183e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a1f770d36ec3d719d3336670bdb2183e0">More...</a><br /></td></tr>
<tr class="separator:a1f770d36ec3d719d3336670bdb2183e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26ce5761a57a4179b98858b7853623c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac26ce5761a57a4179b98858b7853623c">lowest_layer</a> () const</td></tr>
<tr class="memdesc:ac26ce5761a57a4179b98858b7853623c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the lowest layer.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac26ce5761a57a4179b98858b7853623c">More...</a><br /></td></tr>
<tr class="separator:ac26ce5761a57a4179b98858b7853623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26576c8e6d36e76747d1b780b6196b37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a26576c8e6d36e76747d1b780b6196b37">open</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol=<a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a>())</td></tr>
<tr class="memdesc:a26576c8e6d36e76747d1b780b6196b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a26576c8e6d36e76747d1b780b6196b37">More...</a><br /></td></tr>
<tr class="separator:a26576c8e6d36e76747d1b780b6196b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b206ea012bc0a77a9c71d139699083f"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5b206ea012bc0a77a9c71d139699083f">open</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a5b206ea012bc0a77a9c71d139699083f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a5b206ea012bc0a77a9c71d139699083f">More...</a><br /></td></tr>
<tr class="separator:a5b206ea012bc0a77a9c71d139699083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6535d1b89c7b1c5492be594a72e22d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac6535d1b89c7b1c5492be594a72e22d8">assign</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket)</td></tr>
<tr class="memdesc:ac6535d1b89c7b1c5492be594a72e22d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an existing native socket to the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac6535d1b89c7b1c5492be594a72e22d8">More...</a><br /></td></tr>
<tr class="separator:ac6535d1b89c7b1c5492be594a72e22d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8a2175a4afbdcbd5ded9041e1fb15d"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3d8a2175a4afbdcbd5ded9041e1fb15d">assign</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a3d8a2175a4afbdcbd5ded9041e1fb15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an existing native socket to the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a3d8a2175a4afbdcbd5ded9041e1fb15d">More...</a><br /></td></tr>
<tr class="separator:a3d8a2175a4afbdcbd5ded9041e1fb15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fb6eacd32dd56f928e3e90e6bb7b24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a69fb6eacd32dd56f928e3e90e6bb7b24">is_open</a> () const</td></tr>
<tr class="memdesc:a69fb6eacd32dd56f928e3e90e6bb7b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the socket is open.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a69fb6eacd32dd56f928e3e90e6bb7b24">More...</a><br /></td></tr>
<tr class="separator:a69fb6eacd32dd56f928e3e90e6bb7b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdce8530339e4ec98dd5120510282204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204">close</a> ()</td></tr>
<tr class="memdesc:afdce8530339e4ec98dd5120510282204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204">More...</a><br /></td></tr>
<tr class="separator:afdce8530339e4ec98dd5120510282204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af919511c29149305b1ab24e920458733"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#af919511c29149305b1ab24e920458733">close</a> (boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:af919511c29149305b1ab24e920458733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#af919511c29149305b1ab24e920458733">More...</a><br /></td></tr>
<tr class="separator:af919511c29149305b1ab24e920458733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227b2204377ed42af6a9a6f4ca413a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a227b2204377ed42af6a9a6f4ca413a72">release</a> ()</td></tr>
<tr class="memdesc:a227b2204377ed42af6a9a6f4ca413a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of the underlying native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a227b2204377ed42af6a9a6f4ca413a72">More...</a><br /></td></tr>
<tr class="separator:a227b2204377ed42af6a9a6f4ca413a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea481ad3c0b5ec252c560aa032a20a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aea481ad3c0b5ec252c560aa032a20a67">release</a> (boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:aea481ad3c0b5ec252c560aa032a20a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of the underlying native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aea481ad3c0b5ec252c560aa032a20a67">More...</a><br /></td></tr>
<tr class="separator:aea481ad3c0b5ec252c560aa032a20a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2255ad070b1a41ea9e98634a6b2c4df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a2255ad070b1a41ea9e98634a6b2c4df9">native_handle</a> ()</td></tr>
<tr class="memdesc:a2255ad070b1a41ea9e98634a6b2c4df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the native socket representation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a2255ad070b1a41ea9e98634a6b2c4df9">More...</a><br /></td></tr>
<tr class="separator:a2255ad070b1a41ea9e98634a6b2c4df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a83976853db16f08ba074b926b3bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb">cancel</a> ()</td></tr>
<tr class="memdesc:a52a83976853db16f08ba074b926b3bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all asynchronous operations associated with the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb">More...</a><br /></td></tr>
<tr class="separator:a52a83976853db16f08ba074b926b3bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911721f6fec972f23a31190c4cec228c"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a911721f6fec972f23a31190c4cec228c">cancel</a> (boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a911721f6fec972f23a31190c4cec228c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all asynchronous operations associated with the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a911721f6fec972f23a31190c4cec228c">More...</a><br /></td></tr>
<tr class="separator:a911721f6fec972f23a31190c4cec228c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f99ae2d36c9827b09eb8e002240be70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a1f99ae2d36c9827b09eb8e002240be70">at_mark</a> () const</td></tr>
<tr class="memdesc:a1f99ae2d36c9827b09eb8e002240be70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the socket is at the out-of-band data mark.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a1f99ae2d36c9827b09eb8e002240be70">More...</a><br /></td></tr>
<tr class="separator:a1f99ae2d36c9827b09eb8e002240be70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1608bd9a1e1b878fb54e7604247d3ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ad1608bd9a1e1b878fb54e7604247d3ea">at_mark</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:ad1608bd9a1e1b878fb54e7604247d3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the socket is at the out-of-band data mark.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ad1608bd9a1e1b878fb54e7604247d3ea">More...</a><br /></td></tr>
<tr class="separator:ad1608bd9a1e1b878fb54e7604247d3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130284ccf15b2dcc67b17bdbb23f9de1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a130284ccf15b2dcc67b17bdbb23f9de1">available</a> () const</td></tr>
<tr class="memdesc:a130284ccf15b2dcc67b17bdbb23f9de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the number of bytes available for reading.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a130284ccf15b2dcc67b17bdbb23f9de1">More...</a><br /></td></tr>
<tr class="separator:a130284ccf15b2dcc67b17bdbb23f9de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892c95c3645a159f94e133431317e416"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a892c95c3645a159f94e133431317e416">available</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:a892c95c3645a159f94e133431317e416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the number of bytes available for reading.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a892c95c3645a159f94e133431317e416">More...</a><br /></td></tr>
<tr class="separator:a892c95c3645a159f94e133431317e416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cf567fa998b998bd2982c079a4cdba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a25cf567fa998b998bd2982c079a4cdba">bind</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint)</td></tr>
<tr class="memdesc:a25cf567fa998b998bd2982c079a4cdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a25cf567fa998b998bd2982c079a4cdba">More...</a><br /></td></tr>
<tr class="separator:a25cf567fa998b998bd2982c079a4cdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6849b1ba5787b8a8c8558b193480a7e9"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a6849b1ba5787b8a8c8558b193480a7e9">bind</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a6849b1ba5787b8a8c8558b193480a7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a6849b1ba5787b8a8c8558b193480a7e9">More...</a><br /></td></tr>
<tr class="separator:a6849b1ba5787b8a8c8558b193480a7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b82003a1cae324ecedeff6faeee217"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a48b82003a1cae324ecedeff6faeee217">connect</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;peer_endpoint)</td></tr>
<tr class="memdesc:a48b82003a1cae324ecedeff6faeee217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the socket to the specified endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a48b82003a1cae324ecedeff6faeee217">More...</a><br /></td></tr>
<tr class="separator:a48b82003a1cae324ecedeff6faeee217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdf6919cf1d64a43123ffd301872bfa"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0cdf6919cf1d64a43123ffd301872bfa">connect</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;peer_endpoint, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a0cdf6919cf1d64a43123ffd301872bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the socket to the specified endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a0cdf6919cf1d64a43123ffd301872bfa">More...</a><br /></td></tr>
<tr class="separator:a0cdf6919cf1d64a43123ffd301872bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4995b5fb481520b3d7b312da5e04b2a9"><td class="memTemplParams" colspan="2">template&lt;typename ConnectHandler &gt; </td></tr>
<tr class="memitem:a4995b5fb481520b3d7b312da5e04b2a9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a4995b5fb481520b3d7b312da5e04b2a9">BOOST_ASIO_INITFN_RESULT_TYPE</a> (ConnectHandler, void(boost::system::error_code)) async_connect(const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;peer_endpoint</td></tr>
<tr class="memdesc:a4995b5fb481520b3d7b312da5e04b2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous connect.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a4995b5fb481520b3d7b312da5e04b2a9">More...</a><br /></td></tr>
<tr class="separator:a4995b5fb481520b3d7b312da5e04b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07690df72c82afeca1e1da0293bce840"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a07690df72c82afeca1e1da0293bce840">BOOST_ASIO_MOVE_ARG</a> (ConnectHandler) handler)</td></tr>
<tr class="separator:a07690df72c82afeca1e1da0293bce840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a7300fb93369d191e10c30e9910cb7"><td class="memTemplParams" colspan="2">template&lt;typename SettableSocketOption &gt; </td></tr>
<tr class="memitem:aa8a7300fb93369d191e10c30e9910cb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa8a7300fb93369d191e10c30e9910cb7">set_option</a> (const SettableSocketOption &amp;option)</td></tr>
<tr class="memdesc:aa8a7300fb93369d191e10c30e9910cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aa8a7300fb93369d191e10c30e9910cb7">More...</a><br /></td></tr>
<tr class="separator:aa8a7300fb93369d191e10c30e9910cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec41185f85b3ead8586d4158ab4784d1"><td class="memTemplParams" colspan="2">template&lt;typename SettableSocketOption &gt; </td></tr>
<tr class="memitem:aec41185f85b3ead8586d4158ab4784d1"><td class="memTemplItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aec41185f85b3ead8586d4158ab4784d1">set_option</a> (const SettableSocketOption &amp;option, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:aec41185f85b3ead8586d4158ab4784d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aec41185f85b3ead8586d4158ab4784d1">More...</a><br /></td></tr>
<tr class="separator:aec41185f85b3ead8586d4158ab4784d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce9d93dad74f9d8c3754105616b8c61"><td class="memTemplParams" colspan="2">template&lt;typename GettableSocketOption &gt; </td></tr>
<tr class="memitem:a6ce9d93dad74f9d8c3754105616b8c61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a6ce9d93dad74f9d8c3754105616b8c61">get_option</a> (GettableSocketOption &amp;option) const</td></tr>
<tr class="memdesc:a6ce9d93dad74f9d8c3754105616b8c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an option from the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a6ce9d93dad74f9d8c3754105616b8c61">More...</a><br /></td></tr>
<tr class="separator:a6ce9d93dad74f9d8c3754105616b8c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abb98d4a8856876cad0eb2cf2420799"><td class="memTemplParams" colspan="2">template&lt;typename GettableSocketOption &gt; </td></tr>
<tr class="memitem:a0abb98d4a8856876cad0eb2cf2420799"><td class="memTemplItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0abb98d4a8856876cad0eb2cf2420799">get_option</a> (GettableSocketOption &amp;option, boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:a0abb98d4a8856876cad0eb2cf2420799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an option from the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a0abb98d4a8856876cad0eb2cf2420799">More...</a><br /></td></tr>
<tr class="separator:a0abb98d4a8856876cad0eb2cf2420799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="memTemplParams" colspan="2">template&lt;typename IoControlCommand &gt; </td></tr>
<tr class="memitem:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac1b9c5f9b19f0f415e51cef3360953c8">io_control</a> (IoControlCommand &amp;command)</td></tr>
<tr class="memdesc:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac1b9c5f9b19f0f415e51cef3360953c8">More...</a><br /></td></tr>
<tr class="separator:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f422520c4bd3f9e41bfa576c5050dc"><td class="memTemplParams" colspan="2">template&lt;typename IoControlCommand &gt; </td></tr>
<tr class="memitem:a40f422520c4bd3f9e41bfa576c5050dc"><td class="memTemplItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a40f422520c4bd3f9e41bfa576c5050dc">io_control</a> (IoControlCommand &amp;command, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a40f422520c4bd3f9e41bfa576c5050dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a40f422520c4bd3f9e41bfa576c5050dc">More...</a><br /></td></tr>
<tr class="separator:a40f422520c4bd3f9e41bfa576c5050dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5583879f72ebbabf7cba6db1d53e05b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6">non_blocking</a> () const</td></tr>
<tr class="memdesc:a5583879f72ebbabf7cba6db1d53e05b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the non-blocking mode of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6">More...</a><br /></td></tr>
<tr class="separator:a5583879f72ebbabf7cba6db1d53e05b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cb97246819ca03b004303a36215a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab8cb97246819ca03b004303a36215a22">non_blocking</a> (bool mode)</td></tr>
<tr class="memdesc:ab8cb97246819ca03b004303a36215a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab8cb97246819ca03b004303a36215a22">More...</a><br /></td></tr>
<tr class="separator:ab8cb97246819ca03b004303a36215a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af847fa0d78fc4c63edfe85e0da0fa416"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#af847fa0d78fc4c63edfe85e0da0fa416">non_blocking</a> (bool mode, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:af847fa0d78fc4c63edfe85e0da0fa416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#af847fa0d78fc4c63edfe85e0da0fa416">More...</a><br /></td></tr>
<tr class="separator:af847fa0d78fc4c63edfe85e0da0fa416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13f6bf25a6ecc6a12a1ece32c0c5155"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ae13f6bf25a6ecc6a12a1ece32c0c5155">native_non_blocking</a> () const</td></tr>
<tr class="memdesc:ae13f6bf25a6ecc6a12a1ece32c0c5155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the non-blocking mode of the native socket implementation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ae13f6bf25a6ecc6a12a1ece32c0c5155">More...</a><br /></td></tr>
<tr class="separator:ae13f6bf25a6ecc6a12a1ece32c0c5155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab2d02c9fe5c70adc0cd64acee0c505"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a6ab2d02c9fe5c70adc0cd64acee0c505">native_non_blocking</a> (bool mode)</td></tr>
<tr class="memdesc:a6ab2d02c9fe5c70adc0cd64acee0c505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the native socket implementation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a6ab2d02c9fe5c70adc0cd64acee0c505">More...</a><br /></td></tr>
<tr class="separator:a6ab2d02c9fe5c70adc0cd64acee0c505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440a334c97758148d69593027ee086a0"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a440a334c97758148d69593027ee086a0">native_non_blocking</a> (bool mode, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a440a334c97758148d69593027ee086a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the native socket implementation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a440a334c97758148d69593027ee086a0">More...</a><br /></td></tr>
<tr class="separator:a440a334c97758148d69593027ee086a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16392c0e6de7bc65b64ad518e336af0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa16392c0e6de7bc65b64ad518e336af0">local_endpoint</a> () const</td></tr>
<tr class="memdesc:aa16392c0e6de7bc65b64ad518e336af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aa16392c0e6de7bc65b64ad518e336af0">More...</a><br /></td></tr>
<tr class="separator:aa16392c0e6de7bc65b64ad518e336af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0331784d0776292184d63e87693784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aae0331784d0776292184d63e87693784">local_endpoint</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:aae0331784d0776292184d63e87693784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aae0331784d0776292184d63e87693784">More...</a><br /></td></tr>
<tr class="separator:aae0331784d0776292184d63e87693784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe814bdd7411657702a1b53e833b456a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afe814bdd7411657702a1b53e833b456a">remote_endpoint</a> () const</td></tr>
<tr class="memdesc:afe814bdd7411657702a1b53e833b456a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#afe814bdd7411657702a1b53e833b456a">More...</a><br /></td></tr>
<tr class="separator:afe814bdd7411657702a1b53e833b456a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac098a6653e8f75b97ac5d43b13032db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac098a6653e8f75b97ac5d43b13032db9">remote_endpoint</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:ac098a6653e8f75b97ac5d43b13032db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac098a6653e8f75b97ac5d43b13032db9">More...</a><br /></td></tr>
<tr class="separator:ac098a6653e8f75b97ac5d43b13032db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b63df8c121779b9397f34ba04666a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36">shutdown</a> (shutdown_type what)</td></tr>
<tr class="memdesc:a3b63df8c121779b9397f34ba04666a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36">More...</a><br /></td></tr>
<tr class="separator:a3b63df8c121779b9397f34ba04666a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8299c1f15b32b3f43882eb00aa7ba57"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab8299c1f15b32b3f43882eb00aa7ba57">shutdown</a> (shutdown_type what, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:ab8299c1f15b32b3f43882eb00aa7ba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab8299c1f15b32b3f43882eb00aa7ba57">More...</a><br /></td></tr>
<tr class="separator:ab8299c1f15b32b3f43882eb00aa7ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe4c776eafd6ae48e36cc1a39f46f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0fe4c776eafd6ae48e36cc1a39f46f86">wait</a> (wait_type w)</td></tr>
<tr class="separator:a0fe4c776eafd6ae48e36cc1a39f46f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47272c53e40f0a466ec2901d078f054"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa47272c53e40f0a466ec2901d078f054">wait</a> (wait_type w, boost::system::error_code &amp;ec)</td></tr>
<tr class="separator:aa47272c53e40f0a466ec2901d078f054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57721ab2c488aec20ebf45e4c33bb4b"><td class="memTemplParams" colspan="2">template&lt;typename WaitHandler &gt; </td></tr>
<tr class="memitem:aa57721ab2c488aec20ebf45e4c33bb4b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa57721ab2c488aec20ebf45e4c33bb4b">BOOST_ASIO_INITFN_RESULT_TYPE</a> (WaitHandler, void(boost::system::error_code)) async_wait(wait_type w</td></tr>
<tr class="separator:aa57721ab2c488aec20ebf45e4c33bb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adace1cef903348394af07dbd8b3a58a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#adace1cef903348394af07dbd8b3a58a7">BOOST_ASIO_MOVE_ARG</a> (WaitHandler) handler)</td></tr>
<tr class="separator:adace1cef903348394af07dbd8b3a58a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af688355eaa54b356b7ab8df9ba52368f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#af688355eaa54b356b7ab8df9ba52368f">basic_socket_ext</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;ex)</td></tr>
<tr class="memdesc:af688355eaa54b356b7ab8df9ba52368f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket without opening it.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#af688355eaa54b356b7ab8df9ba52368f">More...</a><br /></td></tr>
<tr class="separator:af688355eaa54b356b7ab8df9ba52368f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64332a2fed132f8536f361b8130f44f"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:ad64332a2fed132f8536f361b8130f44f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ad64332a2fed132f8536f361b8130f44f">basic_socket_ext</a> (ExecutionContext &amp;context, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ad64332a2fed132f8536f361b8130f44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket without opening it.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ad64332a2fed132f8536f361b8130f44f">More...</a><br /></td></tr>
<tr class="separator:ad64332a2fed132f8536f361b8130f44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada058fd47609108e17ee9907395acf56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ada058fd47609108e17ee9907395acf56">basic_socket_ext</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;ex, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol)</td></tr>
<tr class="memdesc:ada058fd47609108e17ee9907395acf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and open a basic_socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ada058fd47609108e17ee9907395acf56">More...</a><br /></td></tr>
<tr class="separator:ada058fd47609108e17ee9907395acf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09fd4866cf6478e742bd45f29d9257d"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:ad09fd4866cf6478e742bd45f29d9257d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ad09fd4866cf6478e742bd45f29d9257d">basic_socket_ext</a> (ExecutionContext &amp;context, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ad09fd4866cf6478e742bd45f29d9257d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and open a basic_socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ad09fd4866cf6478e742bd45f29d9257d">More...</a><br /></td></tr>
<tr class="separator:ad09fd4866cf6478e742bd45f29d9257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fec3d3599818343f3890e238a8ca360"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9fec3d3599818343f3890e238a8ca360">basic_socket_ext</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;ex, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint)</td></tr>
<tr class="separator:a9fec3d3599818343f3890e238a8ca360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e636c02cf8c050c1814ea0061271547"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a0e636c02cf8c050c1814ea0061271547"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0e636c02cf8c050c1814ea0061271547">basic_socket_ext</a> (ExecutionContext &amp;context, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:a0e636c02cf8c050c1814ea0061271547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bbe46f4d81495748834603adcfc37c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a57bbe46f4d81495748834603adcfc37c">basic_socket_ext</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;ex, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket)</td></tr>
<tr class="memdesc:a57bbe46f4d81495748834603adcfc37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket on an existing native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a57bbe46f4d81495748834603adcfc37c">More...</a><br /></td></tr>
<tr class="separator:a57bbe46f4d81495748834603adcfc37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b33aa241e122e3df6a53783effe266"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a01b33aa241e122e3df6a53783effe266"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a01b33aa241e122e3df6a53783effe266">basic_socket_ext</a> (ExecutionContext &amp;context, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a01b33aa241e122e3df6a53783effe266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket on an existing native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a01b33aa241e122e3df6a53783effe266">More...</a><br /></td></tr>
<tr class="separator:a01b33aa241e122e3df6a53783effe266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ac2e0a04f3d9093085c831cd1b2e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a95ac2e0a04f3d9093085c831cd1b2e89">get_executor</a> () BOOST_ASIO_NOEXCEPT</td></tr>
<tr class="memdesc:a95ac2e0a04f3d9093085c831cd1b2e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor associated with the object.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a95ac2e0a04f3d9093085c831cd1b2e89">More...</a><br /></td></tr>
<tr class="separator:a95ac2e0a04f3d9093085c831cd1b2e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f770d36ec3d719d3336670bdb2183e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a1f770d36ec3d719d3336670bdb2183e0">lowest_layer</a> ()</td></tr>
<tr class="memdesc:a1f770d36ec3d719d3336670bdb2183e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a1f770d36ec3d719d3336670bdb2183e0">More...</a><br /></td></tr>
<tr class="separator:a1f770d36ec3d719d3336670bdb2183e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26ce5761a57a4179b98858b7853623c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac26ce5761a57a4179b98858b7853623c">lowest_layer</a> () const</td></tr>
<tr class="memdesc:ac26ce5761a57a4179b98858b7853623c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the lowest layer.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac26ce5761a57a4179b98858b7853623c">More...</a><br /></td></tr>
<tr class="separator:ac26ce5761a57a4179b98858b7853623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26576c8e6d36e76747d1b780b6196b37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a26576c8e6d36e76747d1b780b6196b37">open</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol=<a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a>())</td></tr>
<tr class="memdesc:a26576c8e6d36e76747d1b780b6196b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a26576c8e6d36e76747d1b780b6196b37">More...</a><br /></td></tr>
<tr class="separator:a26576c8e6d36e76747d1b780b6196b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b206ea012bc0a77a9c71d139699083f"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5b206ea012bc0a77a9c71d139699083f">open</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a5b206ea012bc0a77a9c71d139699083f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a5b206ea012bc0a77a9c71d139699083f">More...</a><br /></td></tr>
<tr class="separator:a5b206ea012bc0a77a9c71d139699083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6535d1b89c7b1c5492be594a72e22d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac6535d1b89c7b1c5492be594a72e22d8">assign</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket)</td></tr>
<tr class="memdesc:ac6535d1b89c7b1c5492be594a72e22d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an existing native socket to the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac6535d1b89c7b1c5492be594a72e22d8">More...</a><br /></td></tr>
<tr class="separator:ac6535d1b89c7b1c5492be594a72e22d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8a2175a4afbdcbd5ded9041e1fb15d"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3d8a2175a4afbdcbd5ded9041e1fb15d">assign</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a3d8a2175a4afbdcbd5ded9041e1fb15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an existing native socket to the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a3d8a2175a4afbdcbd5ded9041e1fb15d">More...</a><br /></td></tr>
<tr class="separator:a3d8a2175a4afbdcbd5ded9041e1fb15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fb6eacd32dd56f928e3e90e6bb7b24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a69fb6eacd32dd56f928e3e90e6bb7b24">is_open</a> () const</td></tr>
<tr class="memdesc:a69fb6eacd32dd56f928e3e90e6bb7b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the socket is open.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a69fb6eacd32dd56f928e3e90e6bb7b24">More...</a><br /></td></tr>
<tr class="separator:a69fb6eacd32dd56f928e3e90e6bb7b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdce8530339e4ec98dd5120510282204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204">close</a> ()</td></tr>
<tr class="memdesc:afdce8530339e4ec98dd5120510282204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204">More...</a><br /></td></tr>
<tr class="separator:afdce8530339e4ec98dd5120510282204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af919511c29149305b1ab24e920458733"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#af919511c29149305b1ab24e920458733">close</a> (boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:af919511c29149305b1ab24e920458733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#af919511c29149305b1ab24e920458733">More...</a><br /></td></tr>
<tr class="separator:af919511c29149305b1ab24e920458733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227b2204377ed42af6a9a6f4ca413a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a227b2204377ed42af6a9a6f4ca413a72">release</a> ()</td></tr>
<tr class="memdesc:a227b2204377ed42af6a9a6f4ca413a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of the underlying native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a227b2204377ed42af6a9a6f4ca413a72">More...</a><br /></td></tr>
<tr class="separator:a227b2204377ed42af6a9a6f4ca413a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea481ad3c0b5ec252c560aa032a20a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aea481ad3c0b5ec252c560aa032a20a67">release</a> (boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:aea481ad3c0b5ec252c560aa032a20a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of the underlying native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aea481ad3c0b5ec252c560aa032a20a67">More...</a><br /></td></tr>
<tr class="separator:aea481ad3c0b5ec252c560aa032a20a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2255ad070b1a41ea9e98634a6b2c4df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a2255ad070b1a41ea9e98634a6b2c4df9">native_handle</a> ()</td></tr>
<tr class="memdesc:a2255ad070b1a41ea9e98634a6b2c4df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the native socket representation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a2255ad070b1a41ea9e98634a6b2c4df9">More...</a><br /></td></tr>
<tr class="separator:a2255ad070b1a41ea9e98634a6b2c4df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a83976853db16f08ba074b926b3bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb">cancel</a> ()</td></tr>
<tr class="memdesc:a52a83976853db16f08ba074b926b3bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all asynchronous operations associated with the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb">More...</a><br /></td></tr>
<tr class="separator:a52a83976853db16f08ba074b926b3bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911721f6fec972f23a31190c4cec228c"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a911721f6fec972f23a31190c4cec228c">cancel</a> (boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a911721f6fec972f23a31190c4cec228c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all asynchronous operations associated with the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a911721f6fec972f23a31190c4cec228c">More...</a><br /></td></tr>
<tr class="separator:a911721f6fec972f23a31190c4cec228c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f99ae2d36c9827b09eb8e002240be70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a1f99ae2d36c9827b09eb8e002240be70">at_mark</a> () const</td></tr>
<tr class="memdesc:a1f99ae2d36c9827b09eb8e002240be70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the socket is at the out-of-band data mark.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a1f99ae2d36c9827b09eb8e002240be70">More...</a><br /></td></tr>
<tr class="separator:a1f99ae2d36c9827b09eb8e002240be70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1608bd9a1e1b878fb54e7604247d3ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ad1608bd9a1e1b878fb54e7604247d3ea">at_mark</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:ad1608bd9a1e1b878fb54e7604247d3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the socket is at the out-of-band data mark.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ad1608bd9a1e1b878fb54e7604247d3ea">More...</a><br /></td></tr>
<tr class="separator:ad1608bd9a1e1b878fb54e7604247d3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130284ccf15b2dcc67b17bdbb23f9de1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a130284ccf15b2dcc67b17bdbb23f9de1">available</a> () const</td></tr>
<tr class="memdesc:a130284ccf15b2dcc67b17bdbb23f9de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the number of bytes available for reading.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a130284ccf15b2dcc67b17bdbb23f9de1">More...</a><br /></td></tr>
<tr class="separator:a130284ccf15b2dcc67b17bdbb23f9de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892c95c3645a159f94e133431317e416"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a892c95c3645a159f94e133431317e416">available</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:a892c95c3645a159f94e133431317e416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the number of bytes available for reading.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a892c95c3645a159f94e133431317e416">More...</a><br /></td></tr>
<tr class="separator:a892c95c3645a159f94e133431317e416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cf567fa998b998bd2982c079a4cdba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a25cf567fa998b998bd2982c079a4cdba">bind</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint)</td></tr>
<tr class="memdesc:a25cf567fa998b998bd2982c079a4cdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a25cf567fa998b998bd2982c079a4cdba">More...</a><br /></td></tr>
<tr class="separator:a25cf567fa998b998bd2982c079a4cdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6849b1ba5787b8a8c8558b193480a7e9"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a6849b1ba5787b8a8c8558b193480a7e9">bind</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a6849b1ba5787b8a8c8558b193480a7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a6849b1ba5787b8a8c8558b193480a7e9">More...</a><br /></td></tr>
<tr class="separator:a6849b1ba5787b8a8c8558b193480a7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b82003a1cae324ecedeff6faeee217"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a48b82003a1cae324ecedeff6faeee217">connect</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;peer_endpoint)</td></tr>
<tr class="memdesc:a48b82003a1cae324ecedeff6faeee217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the socket to the specified endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a48b82003a1cae324ecedeff6faeee217">More...</a><br /></td></tr>
<tr class="separator:a48b82003a1cae324ecedeff6faeee217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdf6919cf1d64a43123ffd301872bfa"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0cdf6919cf1d64a43123ffd301872bfa">connect</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;peer_endpoint, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a0cdf6919cf1d64a43123ffd301872bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the socket to the specified endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a0cdf6919cf1d64a43123ffd301872bfa">More...</a><br /></td></tr>
<tr class="separator:a0cdf6919cf1d64a43123ffd301872bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4995b5fb481520b3d7b312da5e04b2a9"><td class="memTemplParams" colspan="2">template&lt;typename ConnectHandler &gt; </td></tr>
<tr class="memitem:a4995b5fb481520b3d7b312da5e04b2a9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a4995b5fb481520b3d7b312da5e04b2a9">BOOST_ASIO_INITFN_RESULT_TYPE</a> (ConnectHandler, void(boost::system::error_code)) async_connect(const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;peer_endpoint</td></tr>
<tr class="memdesc:a4995b5fb481520b3d7b312da5e04b2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous connect.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a4995b5fb481520b3d7b312da5e04b2a9">More...</a><br /></td></tr>
<tr class="separator:a4995b5fb481520b3d7b312da5e04b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07690df72c82afeca1e1da0293bce840"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a07690df72c82afeca1e1da0293bce840">BOOST_ASIO_MOVE_ARG</a> (ConnectHandler) handler)</td></tr>
<tr class="separator:a07690df72c82afeca1e1da0293bce840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a7300fb93369d191e10c30e9910cb7"><td class="memTemplParams" colspan="2">template&lt;typename SettableSocketOption &gt; </td></tr>
<tr class="memitem:aa8a7300fb93369d191e10c30e9910cb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa8a7300fb93369d191e10c30e9910cb7">set_option</a> (const SettableSocketOption &amp;option)</td></tr>
<tr class="memdesc:aa8a7300fb93369d191e10c30e9910cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aa8a7300fb93369d191e10c30e9910cb7">More...</a><br /></td></tr>
<tr class="separator:aa8a7300fb93369d191e10c30e9910cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec41185f85b3ead8586d4158ab4784d1"><td class="memTemplParams" colspan="2">template&lt;typename SettableSocketOption &gt; </td></tr>
<tr class="memitem:aec41185f85b3ead8586d4158ab4784d1"><td class="memTemplItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aec41185f85b3ead8586d4158ab4784d1">set_option</a> (const SettableSocketOption &amp;option, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:aec41185f85b3ead8586d4158ab4784d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aec41185f85b3ead8586d4158ab4784d1">More...</a><br /></td></tr>
<tr class="separator:aec41185f85b3ead8586d4158ab4784d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce9d93dad74f9d8c3754105616b8c61"><td class="memTemplParams" colspan="2">template&lt;typename GettableSocketOption &gt; </td></tr>
<tr class="memitem:a6ce9d93dad74f9d8c3754105616b8c61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a6ce9d93dad74f9d8c3754105616b8c61">get_option</a> (GettableSocketOption &amp;option) const</td></tr>
<tr class="memdesc:a6ce9d93dad74f9d8c3754105616b8c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an option from the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a6ce9d93dad74f9d8c3754105616b8c61">More...</a><br /></td></tr>
<tr class="separator:a6ce9d93dad74f9d8c3754105616b8c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abb98d4a8856876cad0eb2cf2420799"><td class="memTemplParams" colspan="2">template&lt;typename GettableSocketOption &gt; </td></tr>
<tr class="memitem:a0abb98d4a8856876cad0eb2cf2420799"><td class="memTemplItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0abb98d4a8856876cad0eb2cf2420799">get_option</a> (GettableSocketOption &amp;option, boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:a0abb98d4a8856876cad0eb2cf2420799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an option from the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a0abb98d4a8856876cad0eb2cf2420799">More...</a><br /></td></tr>
<tr class="separator:a0abb98d4a8856876cad0eb2cf2420799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="memTemplParams" colspan="2">template&lt;typename IoControlCommand &gt; </td></tr>
<tr class="memitem:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac1b9c5f9b19f0f415e51cef3360953c8">io_control</a> (IoControlCommand &amp;command)</td></tr>
<tr class="memdesc:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac1b9c5f9b19f0f415e51cef3360953c8">More...</a><br /></td></tr>
<tr class="separator:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f422520c4bd3f9e41bfa576c5050dc"><td class="memTemplParams" colspan="2">template&lt;typename IoControlCommand &gt; </td></tr>
<tr class="memitem:a40f422520c4bd3f9e41bfa576c5050dc"><td class="memTemplItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a40f422520c4bd3f9e41bfa576c5050dc">io_control</a> (IoControlCommand &amp;command, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a40f422520c4bd3f9e41bfa576c5050dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a40f422520c4bd3f9e41bfa576c5050dc">More...</a><br /></td></tr>
<tr class="separator:a40f422520c4bd3f9e41bfa576c5050dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5583879f72ebbabf7cba6db1d53e05b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6">non_blocking</a> () const</td></tr>
<tr class="memdesc:a5583879f72ebbabf7cba6db1d53e05b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the non-blocking mode of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6">More...</a><br /></td></tr>
<tr class="separator:a5583879f72ebbabf7cba6db1d53e05b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cb97246819ca03b004303a36215a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab8cb97246819ca03b004303a36215a22">non_blocking</a> (bool mode)</td></tr>
<tr class="memdesc:ab8cb97246819ca03b004303a36215a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab8cb97246819ca03b004303a36215a22">More...</a><br /></td></tr>
<tr class="separator:ab8cb97246819ca03b004303a36215a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af847fa0d78fc4c63edfe85e0da0fa416"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#af847fa0d78fc4c63edfe85e0da0fa416">non_blocking</a> (bool mode, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:af847fa0d78fc4c63edfe85e0da0fa416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#af847fa0d78fc4c63edfe85e0da0fa416">More...</a><br /></td></tr>
<tr class="separator:af847fa0d78fc4c63edfe85e0da0fa416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13f6bf25a6ecc6a12a1ece32c0c5155"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ae13f6bf25a6ecc6a12a1ece32c0c5155">native_non_blocking</a> () const</td></tr>
<tr class="memdesc:ae13f6bf25a6ecc6a12a1ece32c0c5155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the non-blocking mode of the native socket implementation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ae13f6bf25a6ecc6a12a1ece32c0c5155">More...</a><br /></td></tr>
<tr class="separator:ae13f6bf25a6ecc6a12a1ece32c0c5155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab2d02c9fe5c70adc0cd64acee0c505"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a6ab2d02c9fe5c70adc0cd64acee0c505">native_non_blocking</a> (bool mode)</td></tr>
<tr class="memdesc:a6ab2d02c9fe5c70adc0cd64acee0c505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the native socket implementation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a6ab2d02c9fe5c70adc0cd64acee0c505">More...</a><br /></td></tr>
<tr class="separator:a6ab2d02c9fe5c70adc0cd64acee0c505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440a334c97758148d69593027ee086a0"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a440a334c97758148d69593027ee086a0">native_non_blocking</a> (bool mode, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a440a334c97758148d69593027ee086a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the native socket implementation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a440a334c97758148d69593027ee086a0">More...</a><br /></td></tr>
<tr class="separator:a440a334c97758148d69593027ee086a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16392c0e6de7bc65b64ad518e336af0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa16392c0e6de7bc65b64ad518e336af0">local_endpoint</a> () const</td></tr>
<tr class="memdesc:aa16392c0e6de7bc65b64ad518e336af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aa16392c0e6de7bc65b64ad518e336af0">More...</a><br /></td></tr>
<tr class="separator:aa16392c0e6de7bc65b64ad518e336af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0331784d0776292184d63e87693784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aae0331784d0776292184d63e87693784">local_endpoint</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:aae0331784d0776292184d63e87693784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aae0331784d0776292184d63e87693784">More...</a><br /></td></tr>
<tr class="separator:aae0331784d0776292184d63e87693784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe814bdd7411657702a1b53e833b456a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afe814bdd7411657702a1b53e833b456a">remote_endpoint</a> () const</td></tr>
<tr class="memdesc:afe814bdd7411657702a1b53e833b456a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#afe814bdd7411657702a1b53e833b456a">More...</a><br /></td></tr>
<tr class="separator:afe814bdd7411657702a1b53e833b456a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac098a6653e8f75b97ac5d43b13032db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac098a6653e8f75b97ac5d43b13032db9">remote_endpoint</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:ac098a6653e8f75b97ac5d43b13032db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac098a6653e8f75b97ac5d43b13032db9">More...</a><br /></td></tr>
<tr class="separator:ac098a6653e8f75b97ac5d43b13032db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b63df8c121779b9397f34ba04666a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36">shutdown</a> (shutdown_type what)</td></tr>
<tr class="memdesc:a3b63df8c121779b9397f34ba04666a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36">More...</a><br /></td></tr>
<tr class="separator:a3b63df8c121779b9397f34ba04666a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8299c1f15b32b3f43882eb00aa7ba57"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab8299c1f15b32b3f43882eb00aa7ba57">shutdown</a> (shutdown_type what, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:ab8299c1f15b32b3f43882eb00aa7ba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab8299c1f15b32b3f43882eb00aa7ba57">More...</a><br /></td></tr>
<tr class="separator:ab8299c1f15b32b3f43882eb00aa7ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe4c776eafd6ae48e36cc1a39f46f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0fe4c776eafd6ae48e36cc1a39f46f86">wait</a> (wait_type w)</td></tr>
<tr class="separator:a0fe4c776eafd6ae48e36cc1a39f46f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47272c53e40f0a466ec2901d078f054"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa47272c53e40f0a466ec2901d078f054">wait</a> (wait_type w, boost::system::error_code &amp;ec)</td></tr>
<tr class="separator:aa47272c53e40f0a466ec2901d078f054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57721ab2c488aec20ebf45e4c33bb4b"><td class="memTemplParams" colspan="2">template&lt;typename WaitHandler &gt; </td></tr>
<tr class="memitem:aa57721ab2c488aec20ebf45e4c33bb4b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa57721ab2c488aec20ebf45e4c33bb4b">BOOST_ASIO_INITFN_RESULT_TYPE</a> (WaitHandler, void(boost::system::error_code)) async_wait(wait_type w</td></tr>
<tr class="separator:aa57721ab2c488aec20ebf45e4c33bb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adace1cef903348394af07dbd8b3a58a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#adace1cef903348394af07dbd8b3a58a7">BOOST_ASIO_MOVE_ARG</a> (WaitHandler) handler)</td></tr>
<tr class="separator:adace1cef903348394af07dbd8b3a58a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af688355eaa54b356b7ab8df9ba52368f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#af688355eaa54b356b7ab8df9ba52368f">basic_socket_ext</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;ex)</td></tr>
<tr class="memdesc:af688355eaa54b356b7ab8df9ba52368f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket without opening it.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#af688355eaa54b356b7ab8df9ba52368f">More...</a><br /></td></tr>
<tr class="separator:af688355eaa54b356b7ab8df9ba52368f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64332a2fed132f8536f361b8130f44f"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:ad64332a2fed132f8536f361b8130f44f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ad64332a2fed132f8536f361b8130f44f">basic_socket_ext</a> (ExecutionContext &amp;context, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ad64332a2fed132f8536f361b8130f44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket without opening it.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ad64332a2fed132f8536f361b8130f44f">More...</a><br /></td></tr>
<tr class="separator:ad64332a2fed132f8536f361b8130f44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada058fd47609108e17ee9907395acf56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ada058fd47609108e17ee9907395acf56">basic_socket_ext</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;ex, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol)</td></tr>
<tr class="memdesc:ada058fd47609108e17ee9907395acf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and open a basic_socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ada058fd47609108e17ee9907395acf56">More...</a><br /></td></tr>
<tr class="separator:ada058fd47609108e17ee9907395acf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09fd4866cf6478e742bd45f29d9257d"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:ad09fd4866cf6478e742bd45f29d9257d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ad09fd4866cf6478e742bd45f29d9257d">basic_socket_ext</a> (ExecutionContext &amp;context, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ad09fd4866cf6478e742bd45f29d9257d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and open a basic_socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ad09fd4866cf6478e742bd45f29d9257d">More...</a><br /></td></tr>
<tr class="separator:ad09fd4866cf6478e742bd45f29d9257d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fec3d3599818343f3890e238a8ca360"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9fec3d3599818343f3890e238a8ca360">basic_socket_ext</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;ex, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint)</td></tr>
<tr class="separator:a9fec3d3599818343f3890e238a8ca360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e636c02cf8c050c1814ea0061271547"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a0e636c02cf8c050c1814ea0061271547"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0e636c02cf8c050c1814ea0061271547">basic_socket_ext</a> (ExecutionContext &amp;context, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:a0e636c02cf8c050c1814ea0061271547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bbe46f4d81495748834603adcfc37c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a57bbe46f4d81495748834603adcfc37c">basic_socket_ext</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;ex, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket)</td></tr>
<tr class="memdesc:a57bbe46f4d81495748834603adcfc37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket on an existing native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a57bbe46f4d81495748834603adcfc37c">More...</a><br /></td></tr>
<tr class="separator:a57bbe46f4d81495748834603adcfc37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b33aa241e122e3df6a53783effe266"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a01b33aa241e122e3df6a53783effe266"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a01b33aa241e122e3df6a53783effe266">basic_socket_ext</a> (ExecutionContext &amp;context, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a01b33aa241e122e3df6a53783effe266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a basic_socket on an existing native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a01b33aa241e122e3df6a53783effe266">More...</a><br /></td></tr>
<tr class="separator:a01b33aa241e122e3df6a53783effe266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ac2e0a04f3d9093085c831cd1b2e89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a95ac2e0a04f3d9093085c831cd1b2e89">get_executor</a> () BOOST_ASIO_NOEXCEPT</td></tr>
<tr class="memdesc:a95ac2e0a04f3d9093085c831cd1b2e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor associated with the object.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a95ac2e0a04f3d9093085c831cd1b2e89">More...</a><br /></td></tr>
<tr class="separator:a95ac2e0a04f3d9093085c831cd1b2e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f770d36ec3d719d3336670bdb2183e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a1f770d36ec3d719d3336670bdb2183e0">lowest_layer</a> ()</td></tr>
<tr class="memdesc:a1f770d36ec3d719d3336670bdb2183e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a1f770d36ec3d719d3336670bdb2183e0">More...</a><br /></td></tr>
<tr class="separator:a1f770d36ec3d719d3336670bdb2183e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26ce5761a57a4179b98858b7853623c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac26ce5761a57a4179b98858b7853623c">lowest_layer</a> () const</td></tr>
<tr class="memdesc:ac26ce5761a57a4179b98858b7853623c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the lowest layer.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac26ce5761a57a4179b98858b7853623c">More...</a><br /></td></tr>
<tr class="separator:ac26ce5761a57a4179b98858b7853623c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26576c8e6d36e76747d1b780b6196b37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a26576c8e6d36e76747d1b780b6196b37">open</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol=<a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a>())</td></tr>
<tr class="memdesc:a26576c8e6d36e76747d1b780b6196b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a26576c8e6d36e76747d1b780b6196b37">More...</a><br /></td></tr>
<tr class="separator:a26576c8e6d36e76747d1b780b6196b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b206ea012bc0a77a9c71d139699083f"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5b206ea012bc0a77a9c71d139699083f">open</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a5b206ea012bc0a77a9c71d139699083f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the socket using the specified protocol.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a5b206ea012bc0a77a9c71d139699083f">More...</a><br /></td></tr>
<tr class="separator:a5b206ea012bc0a77a9c71d139699083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6535d1b89c7b1c5492be594a72e22d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac6535d1b89c7b1c5492be594a72e22d8">assign</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket)</td></tr>
<tr class="memdesc:ac6535d1b89c7b1c5492be594a72e22d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an existing native socket to the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac6535d1b89c7b1c5492be594a72e22d8">More...</a><br /></td></tr>
<tr class="separator:ac6535d1b89c7b1c5492be594a72e22d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8a2175a4afbdcbd5ded9041e1fb15d"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3d8a2175a4afbdcbd5ded9041e1fb15d">assign</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;protocol, const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;native_socket, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a3d8a2175a4afbdcbd5ded9041e1fb15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an existing native socket to the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a3d8a2175a4afbdcbd5ded9041e1fb15d">More...</a><br /></td></tr>
<tr class="separator:a3d8a2175a4afbdcbd5ded9041e1fb15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fb6eacd32dd56f928e3e90e6bb7b24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a69fb6eacd32dd56f928e3e90e6bb7b24">is_open</a> () const</td></tr>
<tr class="memdesc:a69fb6eacd32dd56f928e3e90e6bb7b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the socket is open.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a69fb6eacd32dd56f928e3e90e6bb7b24">More...</a><br /></td></tr>
<tr class="separator:a69fb6eacd32dd56f928e3e90e6bb7b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdce8530339e4ec98dd5120510282204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204">close</a> ()</td></tr>
<tr class="memdesc:afdce8530339e4ec98dd5120510282204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204">More...</a><br /></td></tr>
<tr class="separator:afdce8530339e4ec98dd5120510282204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af919511c29149305b1ab24e920458733"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#af919511c29149305b1ab24e920458733">close</a> (boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:af919511c29149305b1ab24e920458733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#af919511c29149305b1ab24e920458733">More...</a><br /></td></tr>
<tr class="separator:af919511c29149305b1ab24e920458733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227b2204377ed42af6a9a6f4ca413a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a227b2204377ed42af6a9a6f4ca413a72">release</a> ()</td></tr>
<tr class="memdesc:a227b2204377ed42af6a9a6f4ca413a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of the underlying native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a227b2204377ed42af6a9a6f4ca413a72">More...</a><br /></td></tr>
<tr class="separator:a227b2204377ed42af6a9a6f4ca413a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea481ad3c0b5ec252c560aa032a20a67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aea481ad3c0b5ec252c560aa032a20a67">release</a> (boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:aea481ad3c0b5ec252c560aa032a20a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of the underlying native socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aea481ad3c0b5ec252c560aa032a20a67">More...</a><br /></td></tr>
<tr class="separator:aea481ad3c0b5ec252c560aa032a20a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2255ad070b1a41ea9e98634a6b2c4df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a2255ad070b1a41ea9e98634a6b2c4df9">native_handle</a> ()</td></tr>
<tr class="memdesc:a2255ad070b1a41ea9e98634a6b2c4df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the native socket representation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a2255ad070b1a41ea9e98634a6b2c4df9">More...</a><br /></td></tr>
<tr class="separator:a2255ad070b1a41ea9e98634a6b2c4df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a83976853db16f08ba074b926b3bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb">cancel</a> ()</td></tr>
<tr class="memdesc:a52a83976853db16f08ba074b926b3bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all asynchronous operations associated with the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb">More...</a><br /></td></tr>
<tr class="separator:a52a83976853db16f08ba074b926b3bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911721f6fec972f23a31190c4cec228c"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a911721f6fec972f23a31190c4cec228c">cancel</a> (boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a911721f6fec972f23a31190c4cec228c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all asynchronous operations associated with the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a911721f6fec972f23a31190c4cec228c">More...</a><br /></td></tr>
<tr class="separator:a911721f6fec972f23a31190c4cec228c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f99ae2d36c9827b09eb8e002240be70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a1f99ae2d36c9827b09eb8e002240be70">at_mark</a> () const</td></tr>
<tr class="memdesc:a1f99ae2d36c9827b09eb8e002240be70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the socket is at the out-of-band data mark.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a1f99ae2d36c9827b09eb8e002240be70">More...</a><br /></td></tr>
<tr class="separator:a1f99ae2d36c9827b09eb8e002240be70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1608bd9a1e1b878fb54e7604247d3ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ad1608bd9a1e1b878fb54e7604247d3ea">at_mark</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:ad1608bd9a1e1b878fb54e7604247d3ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the socket is at the out-of-band data mark.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ad1608bd9a1e1b878fb54e7604247d3ea">More...</a><br /></td></tr>
<tr class="separator:ad1608bd9a1e1b878fb54e7604247d3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130284ccf15b2dcc67b17bdbb23f9de1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a130284ccf15b2dcc67b17bdbb23f9de1">available</a> () const</td></tr>
<tr class="memdesc:a130284ccf15b2dcc67b17bdbb23f9de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the number of bytes available for reading.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a130284ccf15b2dcc67b17bdbb23f9de1">More...</a><br /></td></tr>
<tr class="separator:a130284ccf15b2dcc67b17bdbb23f9de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892c95c3645a159f94e133431317e416"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a892c95c3645a159f94e133431317e416">available</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:a892c95c3645a159f94e133431317e416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the number of bytes available for reading.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a892c95c3645a159f94e133431317e416">More...</a><br /></td></tr>
<tr class="separator:a892c95c3645a159f94e133431317e416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cf567fa998b998bd2982c079a4cdba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a25cf567fa998b998bd2982c079a4cdba">bind</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint)</td></tr>
<tr class="memdesc:a25cf567fa998b998bd2982c079a4cdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a25cf567fa998b998bd2982c079a4cdba">More...</a><br /></td></tr>
<tr class="separator:a25cf567fa998b998bd2982c079a4cdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6849b1ba5787b8a8c8558b193480a7e9"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a6849b1ba5787b8a8c8558b193480a7e9">bind</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;endpoint, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a6849b1ba5787b8a8c8558b193480a7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the socket to the given local endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a6849b1ba5787b8a8c8558b193480a7e9">More...</a><br /></td></tr>
<tr class="separator:a6849b1ba5787b8a8c8558b193480a7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b82003a1cae324ecedeff6faeee217"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a48b82003a1cae324ecedeff6faeee217">connect</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;peer_endpoint)</td></tr>
<tr class="memdesc:a48b82003a1cae324ecedeff6faeee217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the socket to the specified endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a48b82003a1cae324ecedeff6faeee217">More...</a><br /></td></tr>
<tr class="separator:a48b82003a1cae324ecedeff6faeee217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdf6919cf1d64a43123ffd301872bfa"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0cdf6919cf1d64a43123ffd301872bfa">connect</a> (const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;peer_endpoint, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a0cdf6919cf1d64a43123ffd301872bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect the socket to the specified endpoint.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a0cdf6919cf1d64a43123ffd301872bfa">More...</a><br /></td></tr>
<tr class="separator:a0cdf6919cf1d64a43123ffd301872bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4995b5fb481520b3d7b312da5e04b2a9"><td class="memTemplParams" colspan="2">template&lt;typename ConnectHandler &gt; </td></tr>
<tr class="memitem:a4995b5fb481520b3d7b312da5e04b2a9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a4995b5fb481520b3d7b312da5e04b2a9">BOOST_ASIO_INITFN_RESULT_TYPE</a> (ConnectHandler, void(boost::system::error_code)) async_connect(const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;peer_endpoint</td></tr>
<tr class="memdesc:a4995b5fb481520b3d7b312da5e04b2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous connect.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a4995b5fb481520b3d7b312da5e04b2a9">More...</a><br /></td></tr>
<tr class="separator:a4995b5fb481520b3d7b312da5e04b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07690df72c82afeca1e1da0293bce840"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a07690df72c82afeca1e1da0293bce840">BOOST_ASIO_MOVE_ARG</a> (ConnectHandler) handler)</td></tr>
<tr class="separator:a07690df72c82afeca1e1da0293bce840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a7300fb93369d191e10c30e9910cb7"><td class="memTemplParams" colspan="2">template&lt;typename SettableSocketOption &gt; </td></tr>
<tr class="memitem:aa8a7300fb93369d191e10c30e9910cb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa8a7300fb93369d191e10c30e9910cb7">set_option</a> (const SettableSocketOption &amp;option)</td></tr>
<tr class="memdesc:aa8a7300fb93369d191e10c30e9910cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aa8a7300fb93369d191e10c30e9910cb7">More...</a><br /></td></tr>
<tr class="separator:aa8a7300fb93369d191e10c30e9910cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec41185f85b3ead8586d4158ab4784d1"><td class="memTemplParams" colspan="2">template&lt;typename SettableSocketOption &gt; </td></tr>
<tr class="memitem:aec41185f85b3ead8586d4158ab4784d1"><td class="memTemplItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aec41185f85b3ead8586d4158ab4784d1">set_option</a> (const SettableSocketOption &amp;option, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:aec41185f85b3ead8586d4158ab4784d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aec41185f85b3ead8586d4158ab4784d1">More...</a><br /></td></tr>
<tr class="separator:aec41185f85b3ead8586d4158ab4784d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce9d93dad74f9d8c3754105616b8c61"><td class="memTemplParams" colspan="2">template&lt;typename GettableSocketOption &gt; </td></tr>
<tr class="memitem:a6ce9d93dad74f9d8c3754105616b8c61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a6ce9d93dad74f9d8c3754105616b8c61">get_option</a> (GettableSocketOption &amp;option) const</td></tr>
<tr class="memdesc:a6ce9d93dad74f9d8c3754105616b8c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an option from the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a6ce9d93dad74f9d8c3754105616b8c61">More...</a><br /></td></tr>
<tr class="separator:a6ce9d93dad74f9d8c3754105616b8c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abb98d4a8856876cad0eb2cf2420799"><td class="memTemplParams" colspan="2">template&lt;typename GettableSocketOption &gt; </td></tr>
<tr class="memitem:a0abb98d4a8856876cad0eb2cf2420799"><td class="memTemplItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0abb98d4a8856876cad0eb2cf2420799">get_option</a> (GettableSocketOption &amp;option, boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:a0abb98d4a8856876cad0eb2cf2420799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an option from the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a0abb98d4a8856876cad0eb2cf2420799">More...</a><br /></td></tr>
<tr class="separator:a0abb98d4a8856876cad0eb2cf2420799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="memTemplParams" colspan="2">template&lt;typename IoControlCommand &gt; </td></tr>
<tr class="memitem:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac1b9c5f9b19f0f415e51cef3360953c8">io_control</a> (IoControlCommand &amp;command)</td></tr>
<tr class="memdesc:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac1b9c5f9b19f0f415e51cef3360953c8">More...</a><br /></td></tr>
<tr class="separator:ac1b9c5f9b19f0f415e51cef3360953c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f422520c4bd3f9e41bfa576c5050dc"><td class="memTemplParams" colspan="2">template&lt;typename IoControlCommand &gt; </td></tr>
<tr class="memitem:a40f422520c4bd3f9e41bfa576c5050dc"><td class="memTemplItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a40f422520c4bd3f9e41bfa576c5050dc">io_control</a> (IoControlCommand &amp;command, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a40f422520c4bd3f9e41bfa576c5050dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an IO control command on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a40f422520c4bd3f9e41bfa576c5050dc">More...</a><br /></td></tr>
<tr class="separator:a40f422520c4bd3f9e41bfa576c5050dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5583879f72ebbabf7cba6db1d53e05b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6">non_blocking</a> () const</td></tr>
<tr class="memdesc:a5583879f72ebbabf7cba6db1d53e05b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the non-blocking mode of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6">More...</a><br /></td></tr>
<tr class="separator:a5583879f72ebbabf7cba6db1d53e05b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cb97246819ca03b004303a36215a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab8cb97246819ca03b004303a36215a22">non_blocking</a> (bool mode)</td></tr>
<tr class="memdesc:ab8cb97246819ca03b004303a36215a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab8cb97246819ca03b004303a36215a22">More...</a><br /></td></tr>
<tr class="separator:ab8cb97246819ca03b004303a36215a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af847fa0d78fc4c63edfe85e0da0fa416"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#af847fa0d78fc4c63edfe85e0da0fa416">non_blocking</a> (bool mode, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:af847fa0d78fc4c63edfe85e0da0fa416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#af847fa0d78fc4c63edfe85e0da0fa416">More...</a><br /></td></tr>
<tr class="separator:af847fa0d78fc4c63edfe85e0da0fa416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13f6bf25a6ecc6a12a1ece32c0c5155"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ae13f6bf25a6ecc6a12a1ece32c0c5155">native_non_blocking</a> () const</td></tr>
<tr class="memdesc:ae13f6bf25a6ecc6a12a1ece32c0c5155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the non-blocking mode of the native socket implementation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ae13f6bf25a6ecc6a12a1ece32c0c5155">More...</a><br /></td></tr>
<tr class="separator:ae13f6bf25a6ecc6a12a1ece32c0c5155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab2d02c9fe5c70adc0cd64acee0c505"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a6ab2d02c9fe5c70adc0cd64acee0c505">native_non_blocking</a> (bool mode)</td></tr>
<tr class="memdesc:a6ab2d02c9fe5c70adc0cd64acee0c505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the native socket implementation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a6ab2d02c9fe5c70adc0cd64acee0c505">More...</a><br /></td></tr>
<tr class="separator:a6ab2d02c9fe5c70adc0cd64acee0c505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440a334c97758148d69593027ee086a0"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a440a334c97758148d69593027ee086a0">native_non_blocking</a> (bool mode, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:a440a334c97758148d69593027ee086a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the native socket implementation.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a440a334c97758148d69593027ee086a0">More...</a><br /></td></tr>
<tr class="separator:a440a334c97758148d69593027ee086a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16392c0e6de7bc65b64ad518e336af0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa16392c0e6de7bc65b64ad518e336af0">local_endpoint</a> () const</td></tr>
<tr class="memdesc:aa16392c0e6de7bc65b64ad518e336af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aa16392c0e6de7bc65b64ad518e336af0">More...</a><br /></td></tr>
<tr class="separator:aa16392c0e6de7bc65b64ad518e336af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0331784d0776292184d63e87693784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aae0331784d0776292184d63e87693784">local_endpoint</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:aae0331784d0776292184d63e87693784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#aae0331784d0776292184d63e87693784">More...</a><br /></td></tr>
<tr class="separator:aae0331784d0776292184d63e87693784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe814bdd7411657702a1b53e833b456a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afe814bdd7411657702a1b53e833b456a">remote_endpoint</a> () const</td></tr>
<tr class="memdesc:afe814bdd7411657702a1b53e833b456a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#afe814bdd7411657702a1b53e833b456a">More...</a><br /></td></tr>
<tr class="separator:afe814bdd7411657702a1b53e833b456a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac098a6653e8f75b97ac5d43b13032db9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ac098a6653e8f75b97ac5d43b13032db9">remote_endpoint</a> (boost::system::error_code &amp;ec) const</td></tr>
<tr class="memdesc:ac098a6653e8f75b97ac5d43b13032db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the remote endpoint of the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ac098a6653e8f75b97ac5d43b13032db9">More...</a><br /></td></tr>
<tr class="separator:ac098a6653e8f75b97ac5d43b13032db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b63df8c121779b9397f34ba04666a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36">shutdown</a> (shutdown_type what)</td></tr>
<tr class="memdesc:a3b63df8c121779b9397f34ba04666a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36">More...</a><br /></td></tr>
<tr class="separator:a3b63df8c121779b9397f34ba04666a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8299c1f15b32b3f43882eb00aa7ba57"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#ab8299c1f15b32b3f43882eb00aa7ba57">shutdown</a> (shutdown_type what, boost::system::error_code &amp;ec)</td></tr>
<tr class="memdesc:ab8299c1f15b32b3f43882eb00aa7ba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable sends or receives on the socket.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#ab8299c1f15b32b3f43882eb00aa7ba57">More...</a><br /></td></tr>
<tr class="separator:ab8299c1f15b32b3f43882eb00aa7ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe4c776eafd6ae48e36cc1a39f46f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a0fe4c776eafd6ae48e36cc1a39f46f86">wait</a> (wait_type w)</td></tr>
<tr class="separator:a0fe4c776eafd6ae48e36cc1a39f46f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47272c53e40f0a466ec2901d078f054"><td class="memItemLeft" align="right" valign="top">BOOST_ASIO_SYNC_OP_VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa47272c53e40f0a466ec2901d078f054">wait</a> (wait_type w, boost::system::error_code &amp;ec)</td></tr>
<tr class="separator:aa47272c53e40f0a466ec2901d078f054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57721ab2c488aec20ebf45e4c33bb4b"><td class="memTemplParams" colspan="2">template&lt;typename WaitHandler &gt; </td></tr>
<tr class="memitem:aa57721ab2c488aec20ebf45e4c33bb4b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aa57721ab2c488aec20ebf45e4c33bb4b">BOOST_ASIO_INITFN_RESULT_TYPE</a> (WaitHandler, void(boost::system::error_code)) async_wait(wait_type w</td></tr>
<tr class="separator:aa57721ab2c488aec20ebf45e4c33bb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adace1cef903348394af07dbd8b3a58a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#adace1cef903348394af07dbd8b3a58a7">BOOST_ASIO_MOVE_ARG</a> (WaitHandler) handler)</td></tr>
<tr class="separator:adace1cef903348394af07dbd8b3a58a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acb7f7e5308f6ea5f4da78aa573f97b7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#acb7f7e5308f6ea5f4da78aa573f97b7d">~basic_socket_ext</a> ()</td></tr>
<tr class="memdesc:acb7f7e5308f6ea5f4da78aa573f97b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected destructor to prevent deletion through this type.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#acb7f7e5308f6ea5f4da78aa573f97b7d">More...</a><br /></td></tr>
<tr class="separator:acb7f7e5308f6ea5f4da78aa573f97b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7f7e5308f6ea5f4da78aa573f97b7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#acb7f7e5308f6ea5f4da78aa573f97b7d">~basic_socket_ext</a> ()</td></tr>
<tr class="memdesc:acb7f7e5308f6ea5f4da78aa573f97b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected destructor to prevent deletion through this type.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#acb7f7e5308f6ea5f4da78aa573f97b7d">More...</a><br /></td></tr>
<tr class="separator:acb7f7e5308f6ea5f4da78aa573f97b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7f7e5308f6ea5f4da78aa573f97b7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#acb7f7e5308f6ea5f4da78aa573f97b7d">~basic_socket_ext</a> ()</td></tr>
<tr class="memdesc:acb7f7e5308f6ea5f4da78aa573f97b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected destructor to prevent deletion through this type.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#acb7f7e5308f6ea5f4da78aa573f97b7d">More...</a><br /></td></tr>
<tr class="separator:acb7f7e5308f6ea5f4da78aa573f97b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7f7e5308f6ea5f4da78aa573f97b7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#acb7f7e5308f6ea5f4da78aa573f97b7d">~basic_socket_ext</a> ()</td></tr>
<tr class="memdesc:acb7f7e5308f6ea5f4da78aa573f97b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected destructor to prevent deletion through this type.  <a href="classboost_1_1asio_1_1basic__socket__ext.html#acb7f7e5308f6ea5f4da78aa573f97b7d">More...</a><br /></td></tr>
<tr class="separator:acb7f7e5308f6ea5f4da78aa573f97b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a85ac7721870f90e9de4f0fcd2b8e6c44"><td class="memItemLeft" align="right" valign="top">detail::io_object_impl&lt; <a class="el" href="classboost_1_1asio_1_1detail_1_1reactive__socket__service__ext.html">detail::reactive_socket_service_ext</a>&lt; Protocol &gt;, Executor &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a85ac7721870f90e9de4f0fcd2b8e6c44">impl_</a></td></tr>
<tr class="separator:a85ac7721870f90e9de4f0fcd2b8e6c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt;<br />
class boost::asio::basic_socket_ext&lt; BOOST_ASIO_SVC_TPARAM &gt;</div><p >Provides socket functionality. </p>
<p >The basic_socket class template provides functionality that is common to both stream-oriented and datagram-oriented sockets.</p>
<dl class="section user"><dt>Thread Safety</dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br  />
<em>Shared</em> <em>objects:</em> Unsafe. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00061">61</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aab9a01a2659abf8a5acafa431763772d" name="aab9a01a2659abf8a5acafa431763772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9a01a2659abf8a5acafa431763772d">&#9670;&nbsp;</a></span>endpoint_type <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol::endpoint <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::endpoint_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The endpoint type. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00080">80</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aab9a01a2659abf8a5acafa431763772d" name="aab9a01a2659abf8a5acafa431763772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9a01a2659abf8a5acafa431763772d">&#9670;&nbsp;</a></span>endpoint_type <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol::endpoint <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::endpoint_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The endpoint type. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00101">101</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aab9a01a2659abf8a5acafa431763772d" name="aab9a01a2659abf8a5acafa431763772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9a01a2659abf8a5acafa431763772d">&#9670;&nbsp;</a></span>endpoint_type <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol::endpoint <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::endpoint_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The endpoint type. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00101">101</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aab9a01a2659abf8a5acafa431763772d" name="aab9a01a2659abf8a5acafa431763772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9a01a2659abf8a5acafa431763772d">&#9670;&nbsp;</a></span>endpoint_type <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol::endpoint <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::endpoint_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The endpoint type. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00101">101</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a42d4321011c94952dcbc675ed7360870" name="a42d4321011c94952dcbc675ed7360870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d4321011c94952dcbc675ed7360870">&#9670;&nbsp;</a></span>executor_type <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef io_context::executor_type <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::executor_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the executor associated with the object. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00067">67</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a4c93e86433026ca37402a17ea580f212" name="a4c93e86433026ca37402a17ea580f212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c93e86433026ca37402a17ea580f212">&#9670;&nbsp;</a></span>executor_type <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Executor <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::executor_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the executor associated with the object. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00073">73</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a4c93e86433026ca37402a17ea580f212" name="a4c93e86433026ca37402a17ea580f212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c93e86433026ca37402a17ea580f212">&#9670;&nbsp;</a></span>executor_type <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Executor <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::executor_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the executor associated with the object. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00073">73</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a4c93e86433026ca37402a17ea580f212" name="a4c93e86433026ca37402a17ea580f212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c93e86433026ca37402a17ea580f212">&#9670;&nbsp;</a></span>executor_type <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Executor <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::executor_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the executor associated with the object. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00073">73</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a9a96cb52d5b515905dd6ef052134209e" name="a9a96cb52d5b515905dd6ef052134209e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a96cb52d5b515905dd6ef052134209e">&#9670;&nbsp;</a></span>lowest_layer_type <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a>&lt;Protocol BOOST_ASIO_SVC_TARG&gt; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::lowest_layer_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A basic_socket is always the lowest layer. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00084">84</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab335d2eeee25424657e91a7fb4f58ea3" name="ab335d2eeee25424657e91a7fb4f58ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab335d2eeee25424657e91a7fb4f58ea3">&#9670;&nbsp;</a></span>lowest_layer_type <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a>&lt;Protocol, Executor&gt; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::lowest_layer_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A basic_socket is always the lowest layer. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00105">105</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab335d2eeee25424657e91a7fb4f58ea3" name="ab335d2eeee25424657e91a7fb4f58ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab335d2eeee25424657e91a7fb4f58ea3">&#9670;&nbsp;</a></span>lowest_layer_type <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a>&lt;Protocol, Executor&gt; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::lowest_layer_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A basic_socket is always the lowest layer. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00105">105</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab335d2eeee25424657e91a7fb4f58ea3" name="ab335d2eeee25424657e91a7fb4f58ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab335d2eeee25424657e91a7fb4f58ea3">&#9670;&nbsp;</a></span>lowest_layer_type <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a>&lt;Protocol, Executor&gt; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::lowest_layer_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A basic_socket is always the lowest layer. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00105">105</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a7745ea4769db54c740f43a0c6a17dec6" name="a7745ea4769db54c740f43a0c6a17dec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7745ea4769db54c740f43a0c6a17dec6">&#9670;&nbsp;</a></span>native_handle_type <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef BOOST_ASIO_SVC_T::native_handle_type <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_handle_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The native representation of a socket. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00073">73</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab0872e36afce4710f2709a2b5151e597" name="ab0872e36afce4710f2709a2b5151e597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0872e36afce4710f2709a2b5151e597">&#9670;&nbsp;</a></span>native_handle_type <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classboost_1_1asio_1_1detail_1_1reactive__socket__service__ext.html">detail::reactive_socket_service_ext</a>&lt;Protocol&gt;::native_handle_type <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_handle_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The native representation of a socket. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00094">94</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab0872e36afce4710f2709a2b5151e597" name="ab0872e36afce4710f2709a2b5151e597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0872e36afce4710f2709a2b5151e597">&#9670;&nbsp;</a></span>native_handle_type <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classboost_1_1asio_1_1detail_1_1reactive__socket__service__ext.html">detail::reactive_socket_service_ext</a>&lt;Protocol&gt;::native_handle_type <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_handle_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The native representation of a socket. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00094">94</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab0872e36afce4710f2709a2b5151e597" name="ab0872e36afce4710f2709a2b5151e597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0872e36afce4710f2709a2b5151e597">&#9670;&nbsp;</a></span>native_handle_type <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classboost_1_1asio_1_1detail_1_1reactive__socket__service__ext.html">detail::reactive_socket_service_ext</a>&lt;Protocol&gt;::native_handle_type <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_handle_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The native representation of a socket. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00094">94</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a5989efa6b723759fc9c2f1597d2dfa7f" name="a5989efa6b723759fc9c2f1597d2dfa7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5989efa6b723759fc9c2f1597d2dfa7f">&#9670;&nbsp;</a></span>protocol_type <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::protocol_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The protocol type. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00077">77</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a5989efa6b723759fc9c2f1597d2dfa7f" name="a5989efa6b723759fc9c2f1597d2dfa7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5989efa6b723759fc9c2f1597d2dfa7f">&#9670;&nbsp;</a></span>protocol_type <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::protocol_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The protocol type. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00098">98</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a5989efa6b723759fc9c2f1597d2dfa7f" name="a5989efa6b723759fc9c2f1597d2dfa7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5989efa6b723759fc9c2f1597d2dfa7f">&#9670;&nbsp;</a></span>protocol_type <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::protocol_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The protocol type. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00098">98</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a5989efa6b723759fc9c2f1597d2dfa7f" name="a5989efa6b723759fc9c2f1597d2dfa7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5989efa6b723759fc9c2f1597d2dfa7f">&#9670;&nbsp;</a></span>protocol_type <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::protocol_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The protocol type. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00098">98</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adeb1298a522bb63512a2b802b3e1907e" name="adeb1298a522bb63512a2b802b3e1907e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb1298a522bb63512a2b802b3e1907e">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[1/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">boost::asio::io_context &amp;&#160;</td>
          <td class="paramname"><em>io_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket without opening it. </p>
<p >This constructor creates a socket without opening it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_context</td><td>The io_context object that the socket will use to dispatch handlers for any asynchronous operations performed on the socket. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00094">94</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a2b500569fe6f8405ad6201592072b898" name="a2b500569fe6f8405ad6201592072b898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b500569fe6f8405ad6201592072b898">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[2/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">boost::asio::io_context &amp;&#160;</td>
          <td class="paramname"><em>io_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and open a basic_socket. </p>
<p >This constructor creates and opens a socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_context</td><td>The io_context object that the socket will use to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00110">110</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a819d7360312f50f77288f45d9f746ec5" name="a819d7360312f50f77288f45d9f746ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819d7360312f50f77288f45d9f746ec5">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[3/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">boost::asio::io_context &amp;&#160;</td>
          <td class="paramname"><em>io_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Construct a basic_socket, opening it and binding it to the given local endpoint. This constructor creates a socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_context</td><td>The io_context object that the socket will use to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00134">134</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a9a5ab4ee51d3c93e8cc67cbd55fc8f55" name="a9a5ab4ee51d3c93e8cc67cbd55fc8f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5ab4ee51d3c93e8cc67cbd55fc8f55">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[4/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">boost::asio::io_context &amp;&#160;</td>
          <td class="paramname"><em>io_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket on an existing native socket. </p>
<p >This constructor creates a socket object to hold an existing native socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">io_context</td><td>The io_context object that the socket will use to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
    <tr><td class="paramname">native_socket</td><td>A native socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00159">159</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="acb7f7e5308f6ea5f4da78aa573f97b7d" name="acb7f7e5308f6ea5f4da78aa573f97b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7f7e5308f6ea5f4da78aa573f97b7d">&#9670;&nbsp;</a></span>~basic_socket_ext() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::~<a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected destructor to prevent deletion through this type. </p>
<p >This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling <code>cancel</code>. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01741">1741</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="af688355eaa54b356b7ab8df9ba52368f" name="af688355eaa54b356b7ab8df9ba52368f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af688355eaa54b356b7ab8df9ba52368f">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[5/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket without opening it. </p>
<p >This constructor creates a socket without opening it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00115">115</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ad64332a2fed132f8536f361b8130f44f" name="ad64332a2fed132f8536f361b8130f44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64332a2fed132f8536f361b8130f44f">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[6/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket without opening it. </p>
<p >This constructor creates a socket without opening it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00129">129</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ada058fd47609108e17ee9907395acf56" name="ada058fd47609108e17ee9907395acf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada058fd47609108e17ee9907395acf56">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[7/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and open a basic_socket. </p>
<p >This constructor creates and opens a socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00148">148</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ad09fd4866cf6478e742bd45f29d9257d" name="ad09fd4866cf6478e742bd45f29d9257d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09fd4866cf6478e742bd45f29d9257d">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[8/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and open a basic_socket. </p>
<p >This constructor creates and opens a socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00169">169</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a9fec3d3599818343f3890e238a8ca360" name="a9fec3d3599818343f3890e238a8ca360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fec3d3599818343f3890e238a8ca360">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[9/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Construct a basic_socket, opening it and binding it to the given local endpoint. This constructor creates a socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00195">195</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0e636c02cf8c050c1814ea0061271547" name="a0e636c02cf8c050c1814ea0061271547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e636c02cf8c050c1814ea0061271547">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[10/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Construct a basic_socket, opening it and binding it to the given local endpoint. This constructor creates a socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00223">223</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a57bbe46f4d81495748834603adcfc37c" name="a57bbe46f4d81495748834603adcfc37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bbe46f4d81495748834603adcfc37c">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[11/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket on an existing native socket. </p>
<p >This constructor creates a socket object to hold an existing native socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
    <tr><td class="paramname">native_socket</td><td>A native socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00250">250</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a01b33aa241e122e3df6a53783effe266" name="a01b33aa241e122e3df6a53783effe266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b33aa241e122e3df6a53783effe266">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[12/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket on an existing native socket. </p>
<p >This constructor creates a socket object to hold an existing native socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
    <tr><td class="paramname">native_socket</td><td>A native socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00275">275</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="acb7f7e5308f6ea5f4da78aa573f97b7d" name="acb7f7e5308f6ea5f4da78aa573f97b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7f7e5308f6ea5f4da78aa573f97b7d">&#9670;&nbsp;</a></span>~basic_socket_ext() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::~<a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected destructor to prevent deletion through this type. </p>
<p >This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling <code>cancel</code>. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01789">1789</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="af688355eaa54b356b7ab8df9ba52368f" name="af688355eaa54b356b7ab8df9ba52368f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af688355eaa54b356b7ab8df9ba52368f">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[13/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket without opening it. </p>
<p >This constructor creates a socket without opening it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00115">115</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ad64332a2fed132f8536f361b8130f44f" name="ad64332a2fed132f8536f361b8130f44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64332a2fed132f8536f361b8130f44f">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[14/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket without opening it. </p>
<p >This constructor creates a socket without opening it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00129">129</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ada058fd47609108e17ee9907395acf56" name="ada058fd47609108e17ee9907395acf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada058fd47609108e17ee9907395acf56">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[15/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and open a basic_socket. </p>
<p >This constructor creates and opens a socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00148">148</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ad09fd4866cf6478e742bd45f29d9257d" name="ad09fd4866cf6478e742bd45f29d9257d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09fd4866cf6478e742bd45f29d9257d">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[16/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and open a basic_socket. </p>
<p >This constructor creates and opens a socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00169">169</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a9fec3d3599818343f3890e238a8ca360" name="a9fec3d3599818343f3890e238a8ca360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fec3d3599818343f3890e238a8ca360">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[17/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Construct a basic_socket, opening it and binding it to the given local endpoint. This constructor creates a socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00195">195</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0e636c02cf8c050c1814ea0061271547" name="a0e636c02cf8c050c1814ea0061271547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e636c02cf8c050c1814ea0061271547">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[18/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Construct a basic_socket, opening it and binding it to the given local endpoint. This constructor creates a socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00223">223</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a57bbe46f4d81495748834603adcfc37c" name="a57bbe46f4d81495748834603adcfc37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bbe46f4d81495748834603adcfc37c">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[19/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket on an existing native socket. </p>
<p >This constructor creates a socket object to hold an existing native socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
    <tr><td class="paramname">native_socket</td><td>A native socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00250">250</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a01b33aa241e122e3df6a53783effe266" name="a01b33aa241e122e3df6a53783effe266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b33aa241e122e3df6a53783effe266">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[20/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket on an existing native socket. </p>
<p >This constructor creates a socket object to hold an existing native socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
    <tr><td class="paramname">native_socket</td><td>A native socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00275">275</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="acb7f7e5308f6ea5f4da78aa573f97b7d" name="acb7f7e5308f6ea5f4da78aa573f97b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7f7e5308f6ea5f4da78aa573f97b7d">&#9670;&nbsp;</a></span>~basic_socket_ext() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::~<a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected destructor to prevent deletion through this type. </p>
<p >This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling <code>cancel</code>. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01789">1789</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="af688355eaa54b356b7ab8df9ba52368f" name="af688355eaa54b356b7ab8df9ba52368f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af688355eaa54b356b7ab8df9ba52368f">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[21/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket without opening it. </p>
<p >This constructor creates a socket without opening it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00115">115</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ad64332a2fed132f8536f361b8130f44f" name="ad64332a2fed132f8536f361b8130f44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64332a2fed132f8536f361b8130f44f">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[22/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket without opening it. </p>
<p >This constructor creates a socket without opening it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00129">129</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ada058fd47609108e17ee9907395acf56" name="ada058fd47609108e17ee9907395acf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada058fd47609108e17ee9907395acf56">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[23/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and open a basic_socket. </p>
<p >This constructor creates and opens a socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00148">148</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ad09fd4866cf6478e742bd45f29d9257d" name="ad09fd4866cf6478e742bd45f29d9257d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09fd4866cf6478e742bd45f29d9257d">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[24/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and open a basic_socket. </p>
<p >This constructor creates and opens a socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00169">169</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a9fec3d3599818343f3890e238a8ca360" name="a9fec3d3599818343f3890e238a8ca360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fec3d3599818343f3890e238a8ca360">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[25/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Construct a basic_socket, opening it and binding it to the given local endpoint. This constructor creates a socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00195">195</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0e636c02cf8c050c1814ea0061271547" name="a0e636c02cf8c050c1814ea0061271547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e636c02cf8c050c1814ea0061271547">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[26/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Construct a basic_socket, opening it and binding it to the given local endpoint. This constructor creates a socket and automatically opens it bound to the specified endpoint on the local machine. The protocol used is the protocol associated with the given endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00223">223</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a57bbe46f4d81495748834603adcfc37c" name="a57bbe46f4d81495748834603adcfc37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bbe46f4d81495748834603adcfc37c">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[27/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket on an existing native socket. </p>
<p >This constructor creates a socket object to hold an existing native socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ex</td><td>The I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
    <tr><td class="paramname">native_socket</td><td>A native socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00250">250</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a01b33aa241e122e3df6a53783effe266" name="a01b33aa241e122e3df6a53783effe266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b33aa241e122e3df6a53783effe266">&#9670;&nbsp;</a></span>basic_socket_ext() <span class="overload">[28/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::basic_socket_ext </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, execution_context &amp; &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a basic_socket on an existing native socket. </p>
<p >This constructor creates a socket object to hold an existing native socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>An execution context which provides the I/O executor that the socket will use, by default, to dispatch handlers for any asynchronous operations performed on the socket.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
    <tr><td class="paramname">native_socket</td><td>A native socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00275">275</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="acb7f7e5308f6ea5f4da78aa573f97b7d" name="acb7f7e5308f6ea5f4da78aa573f97b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7f7e5308f6ea5f4da78aa573f97b7d">&#9670;&nbsp;</a></span>~basic_socket_ext() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::~<a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Protected destructor to prevent deletion through this type. </p>
<p >This function destroys the socket, cancelling any outstanding asynchronous operations associated with the socket as if by calling <code>cancel</code>. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01789">1789</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac6535d1b89c7b1c5492be594a72e22d8" name="ac6535d1b89c7b1c5492be594a72e22d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6535d1b89c7b1c5492be594a72e22d8">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an existing native socket to the socket. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00371">371</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac6535d1b89c7b1c5492be594a72e22d8" name="ac6535d1b89c7b1c5492be594a72e22d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6535d1b89c7b1c5492be594a72e22d8">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an existing native socket to the socket. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00460">460</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac6535d1b89c7b1c5492be594a72e22d8" name="ac6535d1b89c7b1c5492be594a72e22d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6535d1b89c7b1c5492be594a72e22d8">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an existing native socket to the socket. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00460">460</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac6535d1b89c7b1c5492be594a72e22d8" name="ac6535d1b89c7b1c5492be594a72e22d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6535d1b89c7b1c5492be594a72e22d8">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an existing native socket to the socket. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00460">460</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a3d8a2175a4afbdcbd5ded9041e1fb15d" name="a3d8a2175a4afbdcbd5ded9041e1fb15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8a2175a4afbdcbd5ded9041e1fb15d">&#9670;&nbsp;</a></span>assign() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an existing native socket to the socket. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00390">390</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a3d8a2175a4afbdcbd5ded9041e1fb15d" name="a3d8a2175a4afbdcbd5ded9041e1fb15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8a2175a4afbdcbd5ded9041e1fb15d">&#9670;&nbsp;</a></span>assign() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an existing native socket to the socket. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00479">479</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a3d8a2175a4afbdcbd5ded9041e1fb15d" name="a3d8a2175a4afbdcbd5ded9041e1fb15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8a2175a4afbdcbd5ded9041e1fb15d">&#9670;&nbsp;</a></span>assign() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an existing native socket to the socket. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00479">479</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a3d8a2175a4afbdcbd5ded9041e1fb15d" name="a3d8a2175a4afbdcbd5ded9041e1fb15d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8a2175a4afbdcbd5ded9041e1fb15d">&#9670;&nbsp;</a></span>assign() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an existing native socket to the socket. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00479">479</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a1f99ae2d36c9827b09eb8e002240be70" name="a1f99ae2d36c9827b09eb8e002240be70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f99ae2d36c9827b09eb8e002240be70">&#9670;&nbsp;</a></span>at_mark() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::at_mark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the socket is at the out-of-band data mark. </p>
<p >This function is used to check whether the socket input is currently positioned at the out-of-band data mark.</p>
<dl class="section return"><dt>Returns</dt><dd>A bool indicating whether the socket is at the out-of-band data mark.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00621">621</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a1f99ae2d36c9827b09eb8e002240be70" name="a1f99ae2d36c9827b09eb8e002240be70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f99ae2d36c9827b09eb8e002240be70">&#9670;&nbsp;</a></span>at_mark() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::at_mark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the socket is at the out-of-band data mark. </p>
<p >This function is used to check whether the socket input is currently positioned at the out-of-band data mark.</p>
<dl class="section return"><dt>Returns</dt><dd>A bool indicating whether the socket is at the out-of-band data mark.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00710">710</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a1f99ae2d36c9827b09eb8e002240be70" name="a1f99ae2d36c9827b09eb8e002240be70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f99ae2d36c9827b09eb8e002240be70">&#9670;&nbsp;</a></span>at_mark() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::at_mark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the socket is at the out-of-band data mark. </p>
<p >This function is used to check whether the socket input is currently positioned at the out-of-band data mark.</p>
<dl class="section return"><dt>Returns</dt><dd>A bool indicating whether the socket is at the out-of-band data mark.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00710">710</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a1f99ae2d36c9827b09eb8e002240be70" name="a1f99ae2d36c9827b09eb8e002240be70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f99ae2d36c9827b09eb8e002240be70">&#9670;&nbsp;</a></span>at_mark() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::at_mark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the socket is at the out-of-band data mark. </p>
<p >This function is used to check whether the socket input is currently positioned at the out-of-band data mark.</p>
<dl class="section return"><dt>Returns</dt><dd>A bool indicating whether the socket is at the out-of-band data mark.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00710">710</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ad1608bd9a1e1b878fb54e7604247d3ea" name="ad1608bd9a1e1b878fb54e7604247d3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1608bd9a1e1b878fb54e7604247d3ea">&#9670;&nbsp;</a></span>at_mark() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::at_mark </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the socket is at the out-of-band data mark. </p>
<p >This function is used to check whether the socket input is currently positioned at the out-of-band data mark.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bool indicating whether the socket is at the out-of-band data mark. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00639">639</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ad1608bd9a1e1b878fb54e7604247d3ea" name="ad1608bd9a1e1b878fb54e7604247d3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1608bd9a1e1b878fb54e7604247d3ea">&#9670;&nbsp;</a></span>at_mark() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::at_mark </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the socket is at the out-of-band data mark. </p>
<p >This function is used to check whether the socket input is currently positioned at the out-of-band data mark.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bool indicating whether the socket is at the out-of-band data mark. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00728">728</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ad1608bd9a1e1b878fb54e7604247d3ea" name="ad1608bd9a1e1b878fb54e7604247d3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1608bd9a1e1b878fb54e7604247d3ea">&#9670;&nbsp;</a></span>at_mark() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::at_mark </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the socket is at the out-of-band data mark. </p>
<p >This function is used to check whether the socket input is currently positioned at the out-of-band data mark.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bool indicating whether the socket is at the out-of-band data mark. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00728">728</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ad1608bd9a1e1b878fb54e7604247d3ea" name="ad1608bd9a1e1b878fb54e7604247d3ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1608bd9a1e1b878fb54e7604247d3ea">&#9670;&nbsp;</a></span>at_mark() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::at_mark </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the socket is at the out-of-band data mark. </p>
<p >This function is used to check whether the socket input is currently positioned at the out-of-band data mark.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bool indicating whether the socket is at the out-of-band data mark. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00728">728</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a130284ccf15b2dcc67b17bdbb23f9de1" name="a130284ccf15b2dcc67b17bdbb23f9de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130284ccf15b2dcc67b17bdbb23f9de1">&#9670;&nbsp;</a></span>available() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the number of bytes available for reading. </p>
<p >This function is used to determine the number of bytes that may be read without blocking.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that may be read without blocking, or 0 if an error occurs.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00654">654</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a130284ccf15b2dcc67b17bdbb23f9de1" name="a130284ccf15b2dcc67b17bdbb23f9de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130284ccf15b2dcc67b17bdbb23f9de1">&#9670;&nbsp;</a></span>available() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the number of bytes available for reading. </p>
<p >This function is used to determine the number of bytes that may be read without blocking.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that may be read without blocking, or 0 if an error occurs.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00743">743</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a130284ccf15b2dcc67b17bdbb23f9de1" name="a130284ccf15b2dcc67b17bdbb23f9de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130284ccf15b2dcc67b17bdbb23f9de1">&#9670;&nbsp;</a></span>available() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the number of bytes available for reading. </p>
<p >This function is used to determine the number of bytes that may be read without blocking.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that may be read without blocking, or 0 if an error occurs.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00743">743</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a130284ccf15b2dcc67b17bdbb23f9de1" name="a130284ccf15b2dcc67b17bdbb23f9de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130284ccf15b2dcc67b17bdbb23f9de1">&#9670;&nbsp;</a></span>available() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the number of bytes available for reading. </p>
<p >This function is used to determine the number of bytes that may be read without blocking.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that may be read without blocking, or 0 if an error occurs.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00743">743</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a892c95c3645a159f94e133431317e416" name="a892c95c3645a159f94e133431317e416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892c95c3645a159f94e133431317e416">&#9670;&nbsp;</a></span>available() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::available </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the number of bytes available for reading. </p>
<p >This function is used to determine the number of bytes that may be read without blocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that may be read without blocking, or 0 if an error occurs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00673">673</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a892c95c3645a159f94e133431317e416" name="a892c95c3645a159f94e133431317e416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892c95c3645a159f94e133431317e416">&#9670;&nbsp;</a></span>available() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::available </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the number of bytes available for reading. </p>
<p >This function is used to determine the number of bytes that may be read without blocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that may be read without blocking, or 0 if an error occurs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00762">762</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a892c95c3645a159f94e133431317e416" name="a892c95c3645a159f94e133431317e416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892c95c3645a159f94e133431317e416">&#9670;&nbsp;</a></span>available() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::available </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the number of bytes available for reading. </p>
<p >This function is used to determine the number of bytes that may be read without blocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that may be read without blocking, or 0 if an error occurs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00762">762</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a892c95c3645a159f94e133431317e416" name="a892c95c3645a159f94e133431317e416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892c95c3645a159f94e133431317e416">&#9670;&nbsp;</a></span>available() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::available </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the number of bytes available for reading. </p>
<p >This function is used to determine the number of bytes that may be read without blocking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes that may be read without blocking, or 0 if an error occurs. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00762">762</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a25cf567fa998b998bd2982c079a4cdba" name="a25cf567fa998b998bd2982c079a4cdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cf567fa998b998bd2982c079a4cdba">&#9670;&nbsp;</a></span>bind() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the socket to the given local endpoint. </p>
<p >This function binds the socket to the specified endpoint on the local machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4());</div>
<div class="line">socket.bind(boost::asio::ip::tcp::endpoint(</div>
<div class="line">      boost::asio::ip::tcp::v4(), 12345));</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00696">696</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a25cf567fa998b998bd2982c079a4cdba" name="a25cf567fa998b998bd2982c079a4cdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cf567fa998b998bd2982c079a4cdba">&#9670;&nbsp;</a></span>bind() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the socket to the given local endpoint. </p>
<p >This function binds the socket to the specified endpoint on the local machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4());</div>
<div class="line">socket.bind(boost::asio::ip::tcp::endpoint(</div>
<div class="line">      boost::asio::ip::tcp::v4(), 12345));</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00785">785</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a25cf567fa998b998bd2982c079a4cdba" name="a25cf567fa998b998bd2982c079a4cdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cf567fa998b998bd2982c079a4cdba">&#9670;&nbsp;</a></span>bind() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the socket to the given local endpoint. </p>
<p >This function binds the socket to the specified endpoint on the local machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4());</div>
<div class="line">socket.bind(boost::asio::ip::tcp::endpoint(</div>
<div class="line">      boost::asio::ip::tcp::v4(), 12345));</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00785">785</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a25cf567fa998b998bd2982c079a4cdba" name="a25cf567fa998b998bd2982c079a4cdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cf567fa998b998bd2982c079a4cdba">&#9670;&nbsp;</a></span>bind() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the socket to the given local endpoint. </p>
<p >This function binds the socket to the specified endpoint on the local machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4());</div>
<div class="line">socket.bind(boost::asio::ip::tcp::endpoint(</div>
<div class="line">      boost::asio::ip::tcp::v4(), 12345));</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00785">785</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a6849b1ba5787b8a8c8558b193480a7e9" name="a6849b1ba5787b8a8c8558b193480a7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6849b1ba5787b8a8c8558b193480a7e9">&#9670;&nbsp;</a></span>bind() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the socket to the given local endpoint. </p>
<p >This function binds the socket to the specified endpoint on the local machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4());</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.bind(boost::asio::ip::tcp::endpoint(</div>
<div class="line">      boost::asio::ip::tcp::v4(), 12345), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00726">726</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a6849b1ba5787b8a8c8558b193480a7e9" name="a6849b1ba5787b8a8c8558b193480a7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6849b1ba5787b8a8c8558b193480a7e9">&#9670;&nbsp;</a></span>bind() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the socket to the given local endpoint. </p>
<p >This function binds the socket to the specified endpoint on the local machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4());</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.bind(boost::asio::ip::tcp::endpoint(</div>
<div class="line">      boost::asio::ip::tcp::v4(), 12345), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00815">815</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a6849b1ba5787b8a8c8558b193480a7e9" name="a6849b1ba5787b8a8c8558b193480a7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6849b1ba5787b8a8c8558b193480a7e9">&#9670;&nbsp;</a></span>bind() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the socket to the given local endpoint. </p>
<p >This function binds the socket to the specified endpoint on the local machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4());</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.bind(boost::asio::ip::tcp::endpoint(</div>
<div class="line">      boost::asio::ip::tcp::v4(), 12345), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00815">815</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a6849b1ba5787b8a8c8558b193480a7e9" name="a6849b1ba5787b8a8c8558b193480a7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6849b1ba5787b8a8c8558b193480a7e9">&#9670;&nbsp;</a></span>bind() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the socket to the given local endpoint. </p>
<p >This function binds the socket to the specified endpoint on the local machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket will be bound.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4());</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.bind(boost::asio::ip::tcp::endpoint(</div>
<div class="line">      boost::asio::ip::tcp::v4(), 12345), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00815">815</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a4995b5fb481520b3d7b312da5e04b2a9" name="a4995b5fb481520b3d7b312da5e04b2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4995b5fb481520b3d7b312da5e04b2a9">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_RESULT_TYPE() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ConnectHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ConnectHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(boost::system::error_code)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous connect. </p>
<p >This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.</p>
<p >The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> boost::system::error_code&amp; error <span class="comment">// Result of operation</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using boost::asio::io_context::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> connect_handler(<span class="keyword">const</span> boost::system::error_code&amp; error)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!error)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Connect succeeded.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint(</div>
<div class="line">    boost::asio::ip::address::from_string(<span class="stringliteral">&quot;1.2.3.4&quot;</span>), 12345);</div>
<div class="line">socket.async_connect(endpoint, connect_handler);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4995b5fb481520b3d7b312da5e04b2a9" name="a4995b5fb481520b3d7b312da5e04b2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4995b5fb481520b3d7b312da5e04b2a9">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_RESULT_TYPE() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ConnectHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ConnectHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(boost::system::error_code)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous connect. </p>
<p >This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.</p>
<p >The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> boost::system::error_code&amp; error <span class="comment">// Result of operation</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> connect_handler(<span class="keyword">const</span> boost::system::error_code&amp; error)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!error)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Connect succeeded.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint(</div>
<div class="line">    boost::asio::ip::address::from_string(<span class="stringliteral">&quot;1.2.3.4&quot;</span>), 12345);</div>
<div class="line">socket.async_connect(endpoint, connect_handler);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4995b5fb481520b3d7b312da5e04b2a9" name="a4995b5fb481520b3d7b312da5e04b2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4995b5fb481520b3d7b312da5e04b2a9">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_RESULT_TYPE() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ConnectHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ConnectHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(boost::system::error_code)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous connect. </p>
<p >This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.</p>
<p >The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> boost::system::error_code&amp; error <span class="comment">// Result of operation</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> connect_handler(<span class="keyword">const</span> boost::system::error_code&amp; error)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!error)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Connect succeeded.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint(</div>
<div class="line">    boost::asio::ip::address::from_string(<span class="stringliteral">&quot;1.2.3.4&quot;</span>), 12345);</div>
<div class="line">socket.async_connect(endpoint, connect_handler);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4995b5fb481520b3d7b312da5e04b2a9" name="a4995b5fb481520b3d7b312da5e04b2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4995b5fb481520b3d7b312da5e04b2a9">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_RESULT_TYPE() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename ConnectHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">ConnectHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(boost::system::error_code)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous connect. </p>
<p >This function is used to asynchronously connect a socket to the specified remote endpoint. The function call always returns immediately.</p>
<p >The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>The remote endpoint to which the socket will be connected. Copies will be made of the endpoint object as required.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connection operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> boost::system::error_code&amp; error <span class="comment">// Result of operation</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> connect_handler(<span class="keyword">const</span> boost::system::error_code&amp; error)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!error)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Connect succeeded.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint(</div>
<div class="line">    boost::asio::ip::address::from_string(<span class="stringliteral">&quot;1.2.3.4&quot;</span>), 12345);</div>
<div class="line">socket.async_connect(endpoint, connect_handler);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa57721ab2c488aec20ebf45e4c33bb4b" name="aa57721ab2c488aec20ebf45e4c33bb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57721ab2c488aec20ebf45e4c33bb4b">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_RESULT_TYPE() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename WaitHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WaitHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(boost::system::error_code)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired socket state.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> boost::system::error_code&amp; error <span class="comment">// Result of operation</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using boost::asio::io_context::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> wait_handler(<span class="keyword">const</span> boost::system::error_code&amp; error)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!error)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Wait succeeded.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa57721ab2c488aec20ebf45e4c33bb4b" name="aa57721ab2c488aec20ebf45e4c33bb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57721ab2c488aec20ebf45e4c33bb4b">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_RESULT_TYPE() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename WaitHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WaitHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(boost::system::error_code)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired socket state.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> boost::system::error_code&amp; error <span class="comment">// Result of operation</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> wait_handler(<span class="keyword">const</span> boost::system::error_code&amp; error)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!error)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Wait succeeded.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa57721ab2c488aec20ebf45e4c33bb4b" name="aa57721ab2c488aec20ebf45e4c33bb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57721ab2c488aec20ebf45e4c33bb4b">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_RESULT_TYPE() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename WaitHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WaitHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(boost::system::error_code)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired socket state.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> boost::system::error_code&amp; error <span class="comment">// Result of operation</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> wait_handler(<span class="keyword">const</span> boost::system::error_code&amp; error)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!error)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Wait succeeded.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa57721ab2c488aec20ebf45e4c33bb4b" name="aa57721ab2c488aec20ebf45e4c33bb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57721ab2c488aec20ebf45e4c33bb4b">&#9670;&nbsp;</a></span>BOOST_ASIO_INITFN_RESULT_TYPE() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename WaitHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_INITFN_RESULT_TYPE </td>
          <td>(</td>
          <td class="paramtype">WaitHandler&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(boost::system::error_code)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error conditions. This function is used to perform an asynchronous wait for a socket to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired socket state.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div>
<div class="line">  <span class="keyword">const</span> boost::system::error_code&amp; error <span class="comment">// Result of operation</span></div>
<div class="line">); </div>
</div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. On immediate completion, invocation of the handler will be performed in a manner equivalent to using boost::asio::post().</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> wait_handler(<span class="keyword">const</span> boost::system::error_code&amp; error)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (!error)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Wait succeeded.</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">socket.async_wait(boost::asio::ip::tcp::socket::wait_read, wait_handler);</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a07690df72c82afeca1e1da0293bce840" name="a07690df72c82afeca1e1da0293bce840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07690df72c82afeca1e1da0293bce840">&#9670;&nbsp;</a></span>BOOST_ASIO_MOVE_ARG() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">ConnectHandler&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00859">859</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a07690df72c82afeca1e1da0293bce840" name="a07690df72c82afeca1e1da0293bce840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07690df72c82afeca1e1da0293bce840">&#9670;&nbsp;</a></span>BOOST_ASIO_MOVE_ARG() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">ConnectHandler&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00948">948</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a07690df72c82afeca1e1da0293bce840" name="a07690df72c82afeca1e1da0293bce840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07690df72c82afeca1e1da0293bce840">&#9670;&nbsp;</a></span>BOOST_ASIO_MOVE_ARG() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">ConnectHandler&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00948">948</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a07690df72c82afeca1e1da0293bce840" name="a07690df72c82afeca1e1da0293bce840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07690df72c82afeca1e1da0293bce840">&#9670;&nbsp;</a></span>BOOST_ASIO_MOVE_ARG() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">ConnectHandler&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00948">948</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="adace1cef903348394af07dbd8b3a58a7" name="adace1cef903348394af07dbd8b3a58a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adace1cef903348394af07dbd8b3a58a7">&#9670;&nbsp;</a></span>BOOST_ASIO_MOVE_ARG() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">WaitHandler&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01715">1715</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="adace1cef903348394af07dbd8b3a58a7" name="adace1cef903348394af07dbd8b3a58a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adace1cef903348394af07dbd8b3a58a7">&#9670;&nbsp;</a></span>BOOST_ASIO_MOVE_ARG() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">WaitHandler&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01777">1777</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="adace1cef903348394af07dbd8b3a58a7" name="adace1cef903348394af07dbd8b3a58a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adace1cef903348394af07dbd8b3a58a7">&#9670;&nbsp;</a></span>BOOST_ASIO_MOVE_ARG() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">WaitHandler&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01777">1777</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="adace1cef903348394af07dbd8b3a58a7" name="adace1cef903348394af07dbd8b3a58a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adace1cef903348394af07dbd8b3a58a7">&#9670;&nbsp;</a></span>BOOST_ASIO_MOVE_ARG() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::BOOST_ASIO_MOVE_ARG </td>
          <td>(</td>
          <td class="paramtype">WaitHandler&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01777">1777</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a52a83976853db16f08ba074b926b3bcb" name="a52a83976853db16f08ba074b926b3bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a83976853db16f08ba074b926b3bcb">&#9670;&nbsp;</a></span>cancel() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all asynchronous operations associated with the socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls to <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb" title="Cancel all asynchronous operations associated with the socket.">cancel()</a> will always fail with boost::asio::error::operation_not_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST_ASIO_ENABLE_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:</dd></dl>
<ul>
<li>It will only cancel asynchronous operations that were initiated in the current thread.</li>
</ul>
<ul>
<li>It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.</li>
</ul>
<p>For portable cancellation, consider using one of the following alternatives:</p>
<ul>
<li>Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.</li>
</ul>
<ul>
<li>Use the <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204" title="Close the socket.">close()</a> function to simultaneously cancel the outstanding operations and close the socket.</li>
</ul>
<p>When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00557">557</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a52a83976853db16f08ba074b926b3bcb" name="a52a83976853db16f08ba074b926b3bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a83976853db16f08ba074b926b3bcb">&#9670;&nbsp;</a></span>cancel() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all asynchronous operations associated with the socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls to <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb" title="Cancel all asynchronous operations associated with the socket.">cancel()</a> will always fail with boost::asio::error::operation_not_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST_ASIO_ENABLE_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:</dd></dl>
<ul>
<li>It will only cancel asynchronous operations that were initiated in the current thread.</li>
</ul>
<ul>
<li>It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.</li>
</ul>
<p>For portable cancellation, consider using one of the following alternatives:</p>
<ul>
<li>Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.</li>
</ul>
<ul>
<li>Use the <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204" title="Close the socket.">close()</a> function to simultaneously cancel the outstanding operations and close the socket.</li>
</ul>
<p>When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00646">646</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a52a83976853db16f08ba074b926b3bcb" name="a52a83976853db16f08ba074b926b3bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a83976853db16f08ba074b926b3bcb">&#9670;&nbsp;</a></span>cancel() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all asynchronous operations associated with the socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls to <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb" title="Cancel all asynchronous operations associated with the socket.">cancel()</a> will always fail with boost::asio::error::operation_not_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST_ASIO_ENABLE_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:</dd></dl>
<ul>
<li>It will only cancel asynchronous operations that were initiated in the current thread.</li>
</ul>
<ul>
<li>It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.</li>
</ul>
<p>For portable cancellation, consider using one of the following alternatives:</p>
<ul>
<li>Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.</li>
</ul>
<ul>
<li>Use the <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204" title="Close the socket.">close()</a> function to simultaneously cancel the outstanding operations and close the socket.</li>
</ul>
<p>When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00646">646</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a52a83976853db16f08ba074b926b3bcb" name="a52a83976853db16f08ba074b926b3bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a83976853db16f08ba074b926b3bcb">&#9670;&nbsp;</a></span>cancel() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all asynchronous operations associated with the socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls to <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb" title="Cancel all asynchronous operations associated with the socket.">cancel()</a> will always fail with boost::asio::error::operation_not_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST_ASIO_ENABLE_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:</dd></dl>
<ul>
<li>It will only cancel asynchronous operations that were initiated in the current thread.</li>
</ul>
<ul>
<li>It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.</li>
</ul>
<p>For portable cancellation, consider using one of the following alternatives:</p>
<ul>
<li>Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.</li>
</ul>
<ul>
<li>Use the <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204" title="Close the socket.">close()</a> function to simultaneously cancel the outstanding operations and close the socket.</li>
</ul>
<p>When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00646">646</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a911721f6fec972f23a31190c4cec228c" name="a911721f6fec972f23a31190c4cec228c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911721f6fec972f23a31190c4cec228c">&#9670;&nbsp;</a></span>cancel() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::cancel </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all asynchronous operations associated with the socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls to <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb" title="Cancel all asynchronous operations associated with the socket.">cancel()</a> will always fail with boost::asio::error::operation_not_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST_ASIO_ENABLE_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:</dd></dl>
<ul>
<li>It will only cancel asynchronous operations that were initiated in the current thread.</li>
</ul>
<ul>
<li>It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.</li>
</ul>
<p>For portable cancellation, consider using one of the following alternatives:</p>
<ul>
<li>Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.</li>
</ul>
<ul>
<li>Use the <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204" title="Close the socket.">close()</a> function to simultaneously cancel the outstanding operations and close the socket.</li>
</ul>
<p>When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00605">605</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a911721f6fec972f23a31190c4cec228c" name="a911721f6fec972f23a31190c4cec228c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911721f6fec972f23a31190c4cec228c">&#9670;&nbsp;</a></span>cancel() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::cancel </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all asynchronous operations associated with the socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls to <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb" title="Cancel all asynchronous operations associated with the socket.">cancel()</a> will always fail with boost::asio::error::operation_not_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST_ASIO_ENABLE_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:</dd></dl>
<ul>
<li>It will only cancel asynchronous operations that were initiated in the current thread.</li>
</ul>
<ul>
<li>It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.</li>
</ul>
<p>For portable cancellation, consider using one of the following alternatives:</p>
<ul>
<li>Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.</li>
</ul>
<ul>
<li>Use the <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204" title="Close the socket.">close()</a> function to simultaneously cancel the outstanding operations and close the socket.</li>
</ul>
<p>When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00694">694</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a911721f6fec972f23a31190c4cec228c" name="a911721f6fec972f23a31190c4cec228c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911721f6fec972f23a31190c4cec228c">&#9670;&nbsp;</a></span>cancel() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::cancel </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all asynchronous operations associated with the socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls to <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb" title="Cancel all asynchronous operations associated with the socket.">cancel()</a> will always fail with boost::asio::error::operation_not_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST_ASIO_ENABLE_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:</dd></dl>
<ul>
<li>It will only cancel asynchronous operations that were initiated in the current thread.</li>
</ul>
<ul>
<li>It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.</li>
</ul>
<p>For portable cancellation, consider using one of the following alternatives:</p>
<ul>
<li>Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.</li>
</ul>
<ul>
<li>Use the <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204" title="Close the socket.">close()</a> function to simultaneously cancel the outstanding operations and close the socket.</li>
</ul>
<p>When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00694">694</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a911721f6fec972f23a31190c4cec228c" name="a911721f6fec972f23a31190c4cec228c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911721f6fec972f23a31190c4cec228c">&#9670;&nbsp;</a></span>cancel() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::cancel </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all asynchronous operations associated with the socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calls to <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a52a83976853db16f08ba074b926b3bcb" title="Cancel all asynchronous operations associated with the socket.">cancel()</a> will always fail with boost::asio::error::operation_not_supported when run on Windows XP, Windows Server 2003, and earlier versions of Windows, unless BOOST_ASIO_ENABLE_CANCELIO is defined. However, the CancelIo function has two issues that should be considered before enabling its use:</dd></dl>
<ul>
<li>It will only cancel asynchronous operations that were initiated in the current thread.</li>
</ul>
<ul>
<li>It can appear to complete without error, but the request to cancel the unfinished operations may be silently ignored by the operating system. Whether it works or not seems to depend on the drivers that are installed.</li>
</ul>
<p>For portable cancellation, consider using one of the following alternatives:</p>
<ul>
<li>Disable asio's I/O completion port backend by defining BOOST_ASIO_DISABLE_IOCP.</li>
</ul>
<ul>
<li>Use the <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#afdce8530339e4ec98dd5120510282204" title="Close the socket.">close()</a> function to simultaneously cancel the outstanding operations and close the socket.</li>
</ul>
<p>When running on Windows Vista, Windows Server 2008, and later, the CancelIoEx function is always used. This function does not have the problems described above. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00694">694</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="afdce8530339e4ec98dd5120510282204" name="afdce8530339e4ec98dd5120510282204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdce8530339e4ec98dd5120510282204">&#9670;&nbsp;</a></span>close() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the socket. </p>
<p >This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For portable behaviour with respect to graceful closure of a connected socket, call <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36" title="Disable sends or receives on the socket.">shutdown()</a> before closing the socket. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00416">416</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="afdce8530339e4ec98dd5120510282204" name="afdce8530339e4ec98dd5120510282204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdce8530339e4ec98dd5120510282204">&#9670;&nbsp;</a></span>close() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the socket. </p>
<p >This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For portable behaviour with respect to graceful closure of a connected socket, call <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36" title="Disable sends or receives on the socket.">shutdown()</a> before closing the socket. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00505">505</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="afdce8530339e4ec98dd5120510282204" name="afdce8530339e4ec98dd5120510282204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdce8530339e4ec98dd5120510282204">&#9670;&nbsp;</a></span>close() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the socket. </p>
<p >This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For portable behaviour with respect to graceful closure of a connected socket, call <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36" title="Disable sends or receives on the socket.">shutdown()</a> before closing the socket. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00505">505</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="afdce8530339e4ec98dd5120510282204" name="afdce8530339e4ec98dd5120510282204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdce8530339e4ec98dd5120510282204">&#9670;&nbsp;</a></span>close() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the socket. </p>
<p >This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. Note that, even if the function indicates an error, the underlying descriptor is closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For portable behaviour with respect to graceful closure of a connected socket, call <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36" title="Disable sends or receives on the socket.">shutdown()</a> before closing the socket. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00505">505</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="af919511c29149305b1ab24e920458733" name="af919511c29149305b1ab24e920458733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af919511c29149305b1ab24e920458733">&#9670;&nbsp;</a></span>close() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::close </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the socket. </p>
<p >This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.close(ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For portable behaviour with respect to graceful closure of a connected socket, call <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36" title="Disable sends or receives on the socket.">shutdown()</a> before closing the socket. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00447">447</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="af919511c29149305b1ab24e920458733" name="af919511c29149305b1ab24e920458733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af919511c29149305b1ab24e920458733">&#9670;&nbsp;</a></span>close() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::close </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the socket. </p>
<p >This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.close(ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For portable behaviour with respect to graceful closure of a connected socket, call <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36" title="Disable sends or receives on the socket.">shutdown()</a> before closing the socket. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00536">536</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="af919511c29149305b1ab24e920458733" name="af919511c29149305b1ab24e920458733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af919511c29149305b1ab24e920458733">&#9670;&nbsp;</a></span>close() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::close </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the socket. </p>
<p >This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.close(ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For portable behaviour with respect to graceful closure of a connected socket, call <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36" title="Disable sends or receives on the socket.">shutdown()</a> before closing the socket. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00536">536</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="af919511c29149305b1ab24e920458733" name="af919511c29149305b1ab24e920458733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af919511c29149305b1ab24e920458733">&#9670;&nbsp;</a></span>close() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::close </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the socket. </p>
<p >This function is used to close the socket. Any asynchronous send, receive or connect operations will be cancelled immediately, and will complete with the boost::asio::error::operation_aborted error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. Note that, even if the function indicates an error, the underlying descriptor is closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.close(ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>For portable behaviour with respect to graceful closure of a connected socket, call <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a3b63df8c121779b9397f34ba04666a36" title="Disable sends or receives on the socket.">shutdown()</a> before closing the socket. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00536">536</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a48b82003a1cae324ecedeff6faeee217" name="a48b82003a1cae324ecedeff6faeee217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b82003a1cae324ecedeff6faeee217">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect the socket to the specified endpoint. </p>
<p >This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.</p>
<p >The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>The remote endpoint to which the socket will be connected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint(</div>
<div class="line">    boost::asio::ip::address::from_string(<span class="stringliteral">&quot;1.2.3.4&quot;</span>), 12345);</div>
<div class="line">socket.connect(endpoint);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00756">756</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a48b82003a1cae324ecedeff6faeee217" name="a48b82003a1cae324ecedeff6faeee217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b82003a1cae324ecedeff6faeee217">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect the socket to the specified endpoint. </p>
<p >This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.</p>
<p >The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>The remote endpoint to which the socket will be connected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint(</div>
<div class="line">    boost::asio::ip::address::from_string(<span class="stringliteral">&quot;1.2.3.4&quot;</span>), 12345);</div>
<div class="line">socket.connect(endpoint);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00845">845</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a48b82003a1cae324ecedeff6faeee217" name="a48b82003a1cae324ecedeff6faeee217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b82003a1cae324ecedeff6faeee217">&#9670;&nbsp;</a></span>connect() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect the socket to the specified endpoint. </p>
<p >This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.</p>
<p >The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>The remote endpoint to which the socket will be connected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint(</div>
<div class="line">    boost::asio::ip::address::from_string(<span class="stringliteral">&quot;1.2.3.4&quot;</span>), 12345);</div>
<div class="line">socket.connect(endpoint);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00845">845</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a48b82003a1cae324ecedeff6faeee217" name="a48b82003a1cae324ecedeff6faeee217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b82003a1cae324ecedeff6faeee217">&#9670;&nbsp;</a></span>connect() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect the socket to the specified endpoint. </p>
<p >This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.</p>
<p >The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>The remote endpoint to which the socket will be connected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint(</div>
<div class="line">    boost::asio::ip::address::from_string(<span class="stringliteral">&quot;1.2.3.4&quot;</span>), 12345);</div>
<div class="line">socket.connect(endpoint);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00845">845</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0cdf6919cf1d64a43123ffd301872bfa" name="a0cdf6919cf1d64a43123ffd301872bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdf6919cf1d64a43123ffd301872bfa">&#9670;&nbsp;</a></span>connect() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect the socket to the specified endpoint. </p>
<p >This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.</p>
<p >The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>The remote endpoint to which the socket will be connected.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint(</div>
<div class="line">    boost::asio::ip::address::from_string(<span class="stringliteral">&quot;1.2.3.4&quot;</span>), 12345);</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.connect(endpoint, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00797">797</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0cdf6919cf1d64a43123ffd301872bfa" name="a0cdf6919cf1d64a43123ffd301872bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdf6919cf1d64a43123ffd301872bfa">&#9670;&nbsp;</a></span>connect() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect the socket to the specified endpoint. </p>
<p >This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.</p>
<p >The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>The remote endpoint to which the socket will be connected.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint(</div>
<div class="line">    boost::asio::ip::address::from_string(<span class="stringliteral">&quot;1.2.3.4&quot;</span>), 12345);</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.connect(endpoint, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00886">886</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0cdf6919cf1d64a43123ffd301872bfa" name="a0cdf6919cf1d64a43123ffd301872bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdf6919cf1d64a43123ffd301872bfa">&#9670;&nbsp;</a></span>connect() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect the socket to the specified endpoint. </p>
<p >This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.</p>
<p >The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>The remote endpoint to which the socket will be connected.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint(</div>
<div class="line">    boost::asio::ip::address::from_string(<span class="stringliteral">&quot;1.2.3.4&quot;</span>), 12345);</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.connect(endpoint, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00886">886</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0cdf6919cf1d64a43123ffd301872bfa" name="a0cdf6919cf1d64a43123ffd301872bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdf6919cf1d64a43123ffd301872bfa">&#9670;&nbsp;</a></span>connect() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Connect the socket to the specified endpoint. </p>
<p >This function is used to connect a socket to the specified remote endpoint. The function call will block until the connection is successfully made or an error occurs.</p>
<p >The socket is automatically opened if it is not already open. If the connect fails, and the socket was automatically opened, the socket is not returned to the closed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>The remote endpoint to which the socket will be connected.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint(</div>
<div class="line">    boost::asio::ip::address::from_string(<span class="stringliteral">&quot;1.2.3.4&quot;</span>), 12345);</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.connect(endpoint, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00886">886</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a95ac2e0a04f3d9093085c831cd1b2e89" name="a95ac2e0a04f3d9093085c831cd1b2e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ac2e0a04f3d9093085c831cd1b2e89">&#9670;&nbsp;</a></span>get_executor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the executor associated with the object. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00278">278</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a95ac2e0a04f3d9093085c831cd1b2e89" name="a95ac2e0a04f3d9093085c831cd1b2e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ac2e0a04f3d9093085c831cd1b2e89">&#9670;&nbsp;</a></span>get_executor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the executor associated with the object. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00368">368</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a95ac2e0a04f3d9093085c831cd1b2e89" name="a95ac2e0a04f3d9093085c831cd1b2e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ac2e0a04f3d9093085c831cd1b2e89">&#9670;&nbsp;</a></span>get_executor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the executor associated with the object. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00368">368</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a95ac2e0a04f3d9093085c831cd1b2e89" name="a95ac2e0a04f3d9093085c831cd1b2e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ac2e0a04f3d9093085c831cd1b2e89">&#9670;&nbsp;</a></span>get_executor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a42d4321011c94952dcbc675ed7360870">executor_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the executor associated with the object. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00368">368</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="afb81a8ec76021ed1c1e443bf373f628b" name="afb81a8ec76021ed1c1e443bf373f628b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb81a8ec76021ed1c1e443bf373f628b">&#9670;&nbsp;</a></span>get_io_context()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::io_context &amp; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_io_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >(Deprecated: Use <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a95ac2e0a04f3d9093085c831cd1b2e89" title="Get the executor associated with the object.">get_executor()</a>.) Get the io_context associated with the object. This function may be used to obtain the io_context object that the I/O object uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the io_context object that the I/O object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00257">257</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="af968f55f9111335061353ee3ba2c7f3a" name="af968f55f9111335061353ee3ba2c7f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af968f55f9111335061353ee3ba2c7f3a">&#9670;&nbsp;</a></span>get_io_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::io_context &amp; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_io_service </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >(Deprecated: Use <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a95ac2e0a04f3d9093085c831cd1b2e89" title="Get the executor associated with the object.">get_executor()</a>.) Get the io_context associated with the object. This function may be used to obtain the io_context object that the I/O object uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the io_context object that the I/O object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00271">271</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a6ce9d93dad74f9d8c3754105616b8c61" name="a6ce9d93dad74f9d8c3754105616b8c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce9d93dad74f9d8c3754105616b8c61">&#9670;&nbsp;</a></span>get_option() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename GettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_option </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an option from the socket. </p>
<p >This function is used to get the current value of an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option value to be obtained from the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>GettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the value of the SOL_SOCKET/SO_KEEPALIVE option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::keep_alive option;</div>
<div class="line">socket.get_option(option);</div>
<div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01024">1024</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a6ce9d93dad74f9d8c3754105616b8c61" name="a6ce9d93dad74f9d8c3754105616b8c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce9d93dad74f9d8c3754105616b8c61">&#9670;&nbsp;</a></span>get_option() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename GettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_option </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an option from the socket. </p>
<p >This function is used to get the current value of an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option value to be obtained from the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>GettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the value of the SOL_SOCKET/SO_KEEPALIVE option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::keep_alive option;</div>
<div class="line">socket.get_option(option);</div>
<div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01086">1086</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a6ce9d93dad74f9d8c3754105616b8c61" name="a6ce9d93dad74f9d8c3754105616b8c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce9d93dad74f9d8c3754105616b8c61">&#9670;&nbsp;</a></span>get_option() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename GettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_option </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an option from the socket. </p>
<p >This function is used to get the current value of an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option value to be obtained from the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>GettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the value of the SOL_SOCKET/SO_KEEPALIVE option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::keep_alive option;</div>
<div class="line">socket.get_option(option);</div>
<div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01086">1086</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a6ce9d93dad74f9d8c3754105616b8c61" name="a6ce9d93dad74f9d8c3754105616b8c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce9d93dad74f9d8c3754105616b8c61">&#9670;&nbsp;</a></span>get_option() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename GettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_option </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an option from the socket. </p>
<p >This function is used to get the current value of an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option value to be obtained from the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>GettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the value of the SOL_SOCKET/SO_KEEPALIVE option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::keep_alive option;</div>
<div class="line">socket.get_option(option);</div>
<div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01086">1086</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0abb98d4a8856876cad0eb2cf2420799" name="a0abb98d4a8856876cad0eb2cf2420799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abb98d4a8856876cad0eb2cf2420799">&#9670;&nbsp;</a></span>get_option() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename GettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_option </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an option from the socket. </p>
<p >This function is used to get the current value of an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option value to be obtained from the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>GettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the value of the SOL_SOCKET/SO_KEEPALIVE option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::keep_alive option;</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.get_option(option, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01072">1072</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0abb98d4a8856876cad0eb2cf2420799" name="a0abb98d4a8856876cad0eb2cf2420799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abb98d4a8856876cad0eb2cf2420799">&#9670;&nbsp;</a></span>get_option() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename GettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_option </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an option from the socket. </p>
<p >This function is used to get the current value of an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option value to be obtained from the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>GettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the value of the SOL_SOCKET/SO_KEEPALIVE option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::keep_alive option;</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.get_option(option, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01134">1134</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0abb98d4a8856876cad0eb2cf2420799" name="a0abb98d4a8856876cad0eb2cf2420799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abb98d4a8856876cad0eb2cf2420799">&#9670;&nbsp;</a></span>get_option() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename GettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_option </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an option from the socket. </p>
<p >This function is used to get the current value of an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option value to be obtained from the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>GettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the value of the SOL_SOCKET/SO_KEEPALIVE option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::keep_alive option;</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.get_option(option, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01134">1134</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0abb98d4a8856876cad0eb2cf2420799" name="a0abb98d4a8856876cad0eb2cf2420799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abb98d4a8856876cad0eb2cf2420799">&#9670;&nbsp;</a></span>get_option() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename GettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::get_option </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an option from the socket. </p>
<p >This function is used to get the current value of an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option value to be obtained from the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>GettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the value of the SOL_SOCKET/SO_KEEPALIVE option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::keep_alive option;</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.get_option(option, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01134">1134</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac1b9c5f9b19f0f415e51cef3360953c8" name="ac1b9c5f9b19f0f415e51cef3360953c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b9c5f9b19f0f415e51cef3360953c8">&#9670;&nbsp;</a></span>io_control() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename IoControlCommand &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::io_control </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an IO control command on the socket. </p>
<p >This function is used to execute an IO control command on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The IO control command to be performed on the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IoControlCommand <br  />
boost::asio::socket_base::bytes_readable <br  />
boost::asio::socket_base::non_blocking_io</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the number of bytes ready to read: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::bytes_readable command;</div>
<div class="line">socket.io_control(command);</div>
<div class="line">std::size_t bytes_readable = command.get();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01102">1102</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac1b9c5f9b19f0f415e51cef3360953c8" name="ac1b9c5f9b19f0f415e51cef3360953c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b9c5f9b19f0f415e51cef3360953c8">&#9670;&nbsp;</a></span>io_control() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename IoControlCommand &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::io_control </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an IO control command on the socket. </p>
<p >This function is used to execute an IO control command on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The IO control command to be performed on the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IoControlCommand <br  />
boost::asio::socket_base::bytes_readable <br  />
boost::asio::socket_base::non_blocking_io</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the number of bytes ready to read: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::bytes_readable command;</div>
<div class="line">socket.io_control(command);</div>
<div class="line">std::size_t bytes_readable = command.get();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01164">1164</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac1b9c5f9b19f0f415e51cef3360953c8" name="ac1b9c5f9b19f0f415e51cef3360953c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b9c5f9b19f0f415e51cef3360953c8">&#9670;&nbsp;</a></span>io_control() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename IoControlCommand &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::io_control </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an IO control command on the socket. </p>
<p >This function is used to execute an IO control command on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The IO control command to be performed on the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IoControlCommand <br  />
boost::asio::socket_base::bytes_readable <br  />
boost::asio::socket_base::non_blocking_io</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the number of bytes ready to read: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::bytes_readable command;</div>
<div class="line">socket.io_control(command);</div>
<div class="line">std::size_t bytes_readable = command.get();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01164">1164</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac1b9c5f9b19f0f415e51cef3360953c8" name="ac1b9c5f9b19f0f415e51cef3360953c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b9c5f9b19f0f415e51cef3360953c8">&#9670;&nbsp;</a></span>io_control() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename IoControlCommand &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::io_control </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an IO control command on the socket. </p>
<p >This function is used to execute an IO control command on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The IO control command to be performed on the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IoControlCommand <br  />
boost::asio::socket_base::bytes_readable <br  />
boost::asio::socket_base::non_blocking_io</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the number of bytes ready to read: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::bytes_readable command;</div>
<div class="line">socket.io_control(command);</div>
<div class="line">std::size_t bytes_readable = command.get();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01164">1164</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a40f422520c4bd3f9e41bfa576c5050dc" name="a40f422520c4bd3f9e41bfa576c5050dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f422520c4bd3f9e41bfa576c5050dc">&#9670;&nbsp;</a></span>io_control() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename IoControlCommand &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::io_control </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an IO control command on the socket. </p>
<p >This function is used to execute an IO control command on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The IO control command to be performed on the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IoControlCommand <br  />
boost::asio::socket_base::bytes_readable <br  />
boost::asio::socket_base::non_blocking_io</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the number of bytes ready to read: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::bytes_readable command;</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.io_control(command, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line">std::size_t bytes_readable = command.get();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01137">1137</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a40f422520c4bd3f9e41bfa576c5050dc" name="a40f422520c4bd3f9e41bfa576c5050dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f422520c4bd3f9e41bfa576c5050dc">&#9670;&nbsp;</a></span>io_control() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename IoControlCommand &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::io_control </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an IO control command on the socket. </p>
<p >This function is used to execute an IO control command on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The IO control command to be performed on the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IoControlCommand <br  />
boost::asio::socket_base::bytes_readable <br  />
boost::asio::socket_base::non_blocking_io</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the number of bytes ready to read: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::bytes_readable command;</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.io_control(command, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line">std::size_t bytes_readable = command.get();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01199">1199</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a40f422520c4bd3f9e41bfa576c5050dc" name="a40f422520c4bd3f9e41bfa576c5050dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f422520c4bd3f9e41bfa576c5050dc">&#9670;&nbsp;</a></span>io_control() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename IoControlCommand &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::io_control </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an IO control command on the socket. </p>
<p >This function is used to execute an IO control command on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The IO control command to be performed on the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IoControlCommand <br  />
boost::asio::socket_base::bytes_readable <br  />
boost::asio::socket_base::non_blocking_io</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the number of bytes ready to read: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::bytes_readable command;</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.io_control(command, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line">std::size_t bytes_readable = command.get();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01199">1199</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a40f422520c4bd3f9e41bfa576c5050dc" name="a40f422520c4bd3f9e41bfa576c5050dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f422520c4bd3f9e41bfa576c5050dc">&#9670;&nbsp;</a></span>io_control() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename IoControlCommand &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::io_control </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an IO control command on the socket. </p>
<p >This function is used to execute an IO control command on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The IO control command to be performed on the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IoControlCommand <br  />
boost::asio::socket_base::bytes_readable <br  />
boost::asio::socket_base::non_blocking_io</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the number of bytes ready to read: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::socket::bytes_readable command;</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.io_control(command, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
<div class="line">std::size_t bytes_readable = command.get();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01199">1199</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a69fb6eacd32dd56f928e3e90e6bb7b24" name="a69fb6eacd32dd56f928e3e90e6bb7b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fb6eacd32dd56f928e3e90e6bb7b24">&#9670;&nbsp;</a></span>is_open() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the socket is open. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00399">399</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a69fb6eacd32dd56f928e3e90e6bb7b24" name="a69fb6eacd32dd56f928e3e90e6bb7b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fb6eacd32dd56f928e3e90e6bb7b24">&#9670;&nbsp;</a></span>is_open() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the socket is open. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00488">488</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a69fb6eacd32dd56f928e3e90e6bb7b24" name="a69fb6eacd32dd56f928e3e90e6bb7b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fb6eacd32dd56f928e3e90e6bb7b24">&#9670;&nbsp;</a></span>is_open() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the socket is open. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00488">488</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a69fb6eacd32dd56f928e3e90e6bb7b24" name="a69fb6eacd32dd56f928e3e90e6bb7b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fb6eacd32dd56f928e3e90e6bb7b24">&#9670;&nbsp;</a></span>is_open() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the socket is open. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00488">488</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aa16392c0e6de7bc65b64ad518e336af0" name="aa16392c0e6de7bc65b64ad518e336af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16392c0e6de7bc65b64ad518e336af0">&#9670;&nbsp;</a></span>local_endpoint() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::local_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local endpoint of the socket. </p>
<p >This function is used to obtain the locally bound endpoint of the socket.</p>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the local endpoint of the socket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01490">1490</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aa16392c0e6de7bc65b64ad518e336af0" name="aa16392c0e6de7bc65b64ad518e336af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16392c0e6de7bc65b64ad518e336af0">&#9670;&nbsp;</a></span>local_endpoint() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::local_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local endpoint of the socket. </p>
<p >This function is used to obtain the locally bound endpoint of the socket.</p>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the local endpoint of the socket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01552">1552</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aa16392c0e6de7bc65b64ad518e336af0" name="aa16392c0e6de7bc65b64ad518e336af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16392c0e6de7bc65b64ad518e336af0">&#9670;&nbsp;</a></span>local_endpoint() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::local_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local endpoint of the socket. </p>
<p >This function is used to obtain the locally bound endpoint of the socket.</p>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the local endpoint of the socket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01552">1552</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aa16392c0e6de7bc65b64ad518e336af0" name="aa16392c0e6de7bc65b64ad518e336af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16392c0e6de7bc65b64ad518e336af0">&#9670;&nbsp;</a></span>local_endpoint() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::local_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local endpoint of the socket. </p>
<p >This function is used to obtain the locally bound endpoint of the socket.</p>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the local endpoint of the socket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01552">1552</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aae0331784d0776292184d63e87693784" name="aae0331784d0776292184d63e87693784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0331784d0776292184d63e87693784">&#9670;&nbsp;</a></span>local_endpoint() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::local_endpoint </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local endpoint of the socket. </p>
<p >This function is used to obtain the locally bound endpoint of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01520">1520</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aae0331784d0776292184d63e87693784" name="aae0331784d0776292184d63e87693784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0331784d0776292184d63e87693784">&#9670;&nbsp;</a></span>local_endpoint() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::local_endpoint </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local endpoint of the socket. </p>
<p >This function is used to obtain the locally bound endpoint of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01582">1582</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aae0331784d0776292184d63e87693784" name="aae0331784d0776292184d63e87693784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0331784d0776292184d63e87693784">&#9670;&nbsp;</a></span>local_endpoint() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::local_endpoint </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local endpoint of the socket. </p>
<p >This function is used to obtain the locally bound endpoint of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01582">1582</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aae0331784d0776292184d63e87693784" name="aae0331784d0776292184d63e87693784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0331784d0776292184d63e87693784">&#9670;&nbsp;</a></span>local_endpoint() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::local_endpoint </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local endpoint of the socket. </p>
<p >This function is used to obtain the locally bound endpoint of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the local endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.local_endpoint(ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01582">1582</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a1f770d36ec3d719d3336670bdb2183e0" name="a1f770d36ec3d719d3336670bdb2183e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f770d36ec3d719d3336670bdb2183e0">&#9670;&nbsp;</a></span>lowest_layer() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the lowest layer. </p>
<p >This function returns a reference to the lowest layer in a stack of layers. Since a basic_socket cannot contain any further layers, it simply returns a reference to itself.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00294">294</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a1f770d36ec3d719d3336670bdb2183e0" name="a1f770d36ec3d719d3336670bdb2183e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f770d36ec3d719d3336670bdb2183e0">&#9670;&nbsp;</a></span>lowest_layer() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the lowest layer. </p>
<p >This function returns a reference to the lowest layer in a stack of layers. Since a basic_socket cannot contain any further layers, it simply returns a reference to itself.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00383">383</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a1f770d36ec3d719d3336670bdb2183e0" name="a1f770d36ec3d719d3336670bdb2183e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f770d36ec3d719d3336670bdb2183e0">&#9670;&nbsp;</a></span>lowest_layer() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the lowest layer. </p>
<p >This function returns a reference to the lowest layer in a stack of layers. Since a basic_socket cannot contain any further layers, it simply returns a reference to itself.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00383">383</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a1f770d36ec3d719d3336670bdb2183e0" name="a1f770d36ec3d719d3336670bdb2183e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f770d36ec3d719d3336670bdb2183e0">&#9670;&nbsp;</a></span>lowest_layer() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the lowest layer. </p>
<p >This function returns a reference to the lowest layer in a stack of layers. Since a basic_socket cannot contain any further layers, it simply returns a reference to itself.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00383">383</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac26ce5761a57a4179b98858b7853623c" name="ac26ce5761a57a4179b98858b7853623c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26ce5761a57a4179b98858b7853623c">&#9670;&nbsp;</a></span>lowest_layer() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the lowest layer. </p>
<p >This function returns a const reference to the lowest layer in a stack of layers. Since a basic_socket cannot contain any further layers, it simply returns a reference to itself.</p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00308">308</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac26ce5761a57a4179b98858b7853623c" name="ac26ce5761a57a4179b98858b7853623c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26ce5761a57a4179b98858b7853623c">&#9670;&nbsp;</a></span>lowest_layer() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the lowest layer. </p>
<p >This function returns a const reference to the lowest layer in a stack of layers. Since a basic_socket cannot contain any further layers, it simply returns a reference to itself.</p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00397">397</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac26ce5761a57a4179b98858b7853623c" name="ac26ce5761a57a4179b98858b7853623c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26ce5761a57a4179b98858b7853623c">&#9670;&nbsp;</a></span>lowest_layer() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the lowest layer. </p>
<p >This function returns a const reference to the lowest layer in a stack of layers. Since a basic_socket cannot contain any further layers, it simply returns a reference to itself.</p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00397">397</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac26ce5761a57a4179b98858b7853623c" name="ac26ce5761a57a4179b98858b7853623c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26ce5761a57a4179b98858b7853623c">&#9670;&nbsp;</a></span>lowest_layer() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a9a96cb52d5b515905dd6ef052134209e">lowest_layer_type</a> &amp; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the lowest layer. </p>
<p >This function returns a const reference to the lowest layer in a stack of layers. Since a basic_socket cannot contain any further layers, it simply returns a reference to itself.</p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00397">397</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a2255ad070b1a41ea9e98634a6b2c4df9" name="a2255ad070b1a41ea9e98634a6b2c4df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2255ad070b1a41ea9e98634a6b2c4df9">&#9670;&nbsp;</a></span>native_handle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the native socket representation. </p>
<p >This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. </p>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00511">511</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a2255ad070b1a41ea9e98634a6b2c4df9" name="a2255ad070b1a41ea9e98634a6b2c4df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2255ad070b1a41ea9e98634a6b2c4df9">&#9670;&nbsp;</a></span>native_handle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the native socket representation. </p>
<p >This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. </p>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00600">600</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a2255ad070b1a41ea9e98634a6b2c4df9" name="a2255ad070b1a41ea9e98634a6b2c4df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2255ad070b1a41ea9e98634a6b2c4df9">&#9670;&nbsp;</a></span>native_handle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the native socket representation. </p>
<p >This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. </p>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00600">600</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a2255ad070b1a41ea9e98634a6b2c4df9" name="a2255ad070b1a41ea9e98634a6b2c4df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2255ad070b1a41ea9e98634a6b2c4df9">&#9670;&nbsp;</a></span>native_handle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the native socket representation. </p>
<p >This function may be used to obtain the underlying representation of the socket. This is intended to allow access to native socket functionality that is not otherwise provided. </p>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00600">600</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ae13f6bf25a6ecc6a12a1ece32c0c5155" name="ae13f6bf25a6ecc6a12a1ece32c0c5155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13f6bf25a6ecc6a12a1ece32c0c5155">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the non-blocking mode of the native socket implementation. </p>
<p >This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the underlying socket is in non-blocking mode and direct system calls may fail with boost::asio::error::would_block (or the equivalent system error).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's <code>sendfile</code> system call might be encapsulated: <div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>sendfile_op</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; sock_;</div>
<div class="line">  <span class="keywordtype">int</span> fd_;</div>
<div class="line">  Handler handler_;</div>
<div class="line">  off_t offset_;</div>
<div class="line">  std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function call operator meeting WriteHandler requirements.</span></div>
<div class="line">  <span class="comment">// Used as the handler for the async_write_some operation.</span></div>
<div class="line">  <span class="keywordtype">void</span> operator()(boost::system::error_code ec, std::size_t)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Put the underlying socket into non-blocking mode.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">      <span class="keywordflow">if</span> (!sock_.native_non_blocking())</div>
<div class="line">        sock_.native_non_blocking(<span class="keyword">true</span>, ec);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (;;)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Try the system call.</span></div>
<div class="line">        errno = 0;</div>
<div class="line">        <span class="keywordtype">int</span> n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</div>
<div class="line">        ec = boost::system::error_code(n &lt; 0 ? errno : 0,</div>
<div class="line">            boost::asio::error::get_system_category());</div>
<div class="line">        total_bytes_transferred_ += ec ? 0 : n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Retry operation immediately if interrupted by signal.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::interrupted)</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if we need to run the operation again.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::would_block</div>
<div class="line">            || ec == boost::asio::error::try_again)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// We have to wait for the socket to become ready again.</span></div>
<div class="line">          sock_.async_wait(tcp::socket::wait_write, *<span class="keyword">this</span>);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec || n == 0)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// An error occurred, or we have reached the end of the file.</span></div>
<div class="line">          <span class="comment">// Either way we must exit the loop so we can call the handler.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop around to try calling sendfile again.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass result back to user&#39;s handler.</span></div>
<div class="line">    handler_(ec, total_bytes_transferred_);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_sendfile(tcp::socket&amp; sock, <span class="keywordtype">int</span> fd, Handler h)</div>
<div class="line">{</div>
<div class="line">  sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</div>
<div class="line">  sock.async_wait(tcp::socket::wait_write, op);</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01284">1284</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ae13f6bf25a6ecc6a12a1ece32c0c5155" name="ae13f6bf25a6ecc6a12a1ece32c0c5155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13f6bf25a6ecc6a12a1ece32c0c5155">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the non-blocking mode of the native socket implementation. </p>
<p >This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the underlying socket is in non-blocking mode and direct system calls may fail with boost::asio::error::would_block (or the equivalent system error).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's <code>sendfile</code> system call might be encapsulated: <div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>sendfile_op</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; sock_;</div>
<div class="line">  <span class="keywordtype">int</span> fd_;</div>
<div class="line">  Handler handler_;</div>
<div class="line">  off_t offset_;</div>
<div class="line">  std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function call operator meeting WriteHandler requirements.</span></div>
<div class="line">  <span class="comment">// Used as the handler for the async_write_some operation.</span></div>
<div class="line">  <span class="keywordtype">void</span> operator()(boost::system::error_code ec, std::size_t)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Put the underlying socket into non-blocking mode.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">      <span class="keywordflow">if</span> (!sock_.native_non_blocking())</div>
<div class="line">        sock_.native_non_blocking(<span class="keyword">true</span>, ec);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (;;)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Try the system call.</span></div>
<div class="line">        errno = 0;</div>
<div class="line">        <span class="keywordtype">int</span> n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</div>
<div class="line">        ec = boost::system::error_code(n &lt; 0 ? errno : 0,</div>
<div class="line">            boost::asio::error::get_system_category());</div>
<div class="line">        total_bytes_transferred_ += ec ? 0 : n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Retry operation immediately if interrupted by signal.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::interrupted)</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if we need to run the operation again.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::would_block</div>
<div class="line">            || ec == boost::asio::error::try_again)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// We have to wait for the socket to become ready again.</span></div>
<div class="line">          sock_.async_wait(tcp::socket::wait_write, *<span class="keyword">this</span>);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec || n == 0)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// An error occurred, or we have reached the end of the file.</span></div>
<div class="line">          <span class="comment">// Either way we must exit the loop so we can call the handler.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop around to try calling sendfile again.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass result back to user&#39;s handler.</span></div>
<div class="line">    handler_(ec, total_bytes_transferred_);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_sendfile(tcp::socket&amp; sock, <span class="keywordtype">int</span> fd, Handler h)</div>
<div class="line">{</div>
<div class="line">  sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</div>
<div class="line">  sock.async_wait(tcp::socket::wait_write, op);</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01346">1346</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ae13f6bf25a6ecc6a12a1ece32c0c5155" name="ae13f6bf25a6ecc6a12a1ece32c0c5155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13f6bf25a6ecc6a12a1ece32c0c5155">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the non-blocking mode of the native socket implementation. </p>
<p >This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the underlying socket is in non-blocking mode and direct system calls may fail with boost::asio::error::would_block (or the equivalent system error).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's <code>sendfile</code> system call might be encapsulated: <div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>sendfile_op</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; sock_;</div>
<div class="line">  <span class="keywordtype">int</span> fd_;</div>
<div class="line">  Handler handler_;</div>
<div class="line">  off_t offset_;</div>
<div class="line">  std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function call operator meeting WriteHandler requirements.</span></div>
<div class="line">  <span class="comment">// Used as the handler for the async_write_some operation.</span></div>
<div class="line">  <span class="keywordtype">void</span> operator()(boost::system::error_code ec, std::size_t)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Put the underlying socket into non-blocking mode.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">      <span class="keywordflow">if</span> (!sock_.native_non_blocking())</div>
<div class="line">        sock_.native_non_blocking(<span class="keyword">true</span>, ec);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (;;)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Try the system call.</span></div>
<div class="line">        errno = 0;</div>
<div class="line">        <span class="keywordtype">int</span> n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</div>
<div class="line">        ec = boost::system::error_code(n &lt; 0 ? errno : 0,</div>
<div class="line">            boost::asio::error::get_system_category());</div>
<div class="line">        total_bytes_transferred_ += ec ? 0 : n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Retry operation immediately if interrupted by signal.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::interrupted)</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if we need to run the operation again.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::would_block</div>
<div class="line">            || ec == boost::asio::error::try_again)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// We have to wait for the socket to become ready again.</span></div>
<div class="line">          sock_.async_wait(tcp::socket::wait_write, *<span class="keyword">this</span>);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec || n == 0)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// An error occurred, or we have reached the end of the file.</span></div>
<div class="line">          <span class="comment">// Either way we must exit the loop so we can call the handler.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop around to try calling sendfile again.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass result back to user&#39;s handler.</span></div>
<div class="line">    handler_(ec, total_bytes_transferred_);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_sendfile(tcp::socket&amp; sock, <span class="keywordtype">int</span> fd, Handler h)</div>
<div class="line">{</div>
<div class="line">  sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</div>
<div class="line">  sock.async_wait(tcp::socket::wait_write, op);</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01346">1346</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ae13f6bf25a6ecc6a12a1ece32c0c5155" name="ae13f6bf25a6ecc6a12a1ece32c0c5155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13f6bf25a6ecc6a12a1ece32c0c5155">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the non-blocking mode of the native socket implementation. </p>
<p >This function is used to retrieve the non-blocking mode of the underlying native socket. This mode has no effect on the behaviour of the socket object's synchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the underlying socket is in non-blocking mode and direct system calls may fail with boost::asio::error::would_block (or the equivalent system error).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The current non-blocking mode is cached by the socket object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native socket.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's <code>sendfile</code> system call might be encapsulated: <div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>sendfile_op</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; sock_;</div>
<div class="line">  <span class="keywordtype">int</span> fd_;</div>
<div class="line">  Handler handler_;</div>
<div class="line">  off_t offset_;</div>
<div class="line">  std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function call operator meeting WriteHandler requirements.</span></div>
<div class="line">  <span class="comment">// Used as the handler for the async_write_some operation.</span></div>
<div class="line">  <span class="keywordtype">void</span> operator()(boost::system::error_code ec, std::size_t)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Put the underlying socket into non-blocking mode.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">      <span class="keywordflow">if</span> (!sock_.native_non_blocking())</div>
<div class="line">        sock_.native_non_blocking(<span class="keyword">true</span>, ec);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (;;)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Try the system call.</span></div>
<div class="line">        errno = 0;</div>
<div class="line">        <span class="keywordtype">int</span> n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</div>
<div class="line">        ec = boost::system::error_code(n &lt; 0 ? errno : 0,</div>
<div class="line">            boost::asio::error::get_system_category());</div>
<div class="line">        total_bytes_transferred_ += ec ? 0 : n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Retry operation immediately if interrupted by signal.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::interrupted)</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if we need to run the operation again.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::would_block</div>
<div class="line">            || ec == boost::asio::error::try_again)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// We have to wait for the socket to become ready again.</span></div>
<div class="line">          sock_.async_wait(tcp::socket::wait_write, *<span class="keyword">this</span>);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec || n == 0)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// An error occurred, or we have reached the end of the file.</span></div>
<div class="line">          <span class="comment">// Either way we must exit the loop so we can call the handler.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop around to try calling sendfile again.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass result back to user&#39;s handler.</span></div>
<div class="line">    handler_(ec, total_bytes_transferred_);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_sendfile(tcp::socket&amp; sock, <span class="keywordtype">int</span> fd, Handler h)</div>
<div class="line">{</div>
<div class="line">  sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</div>
<div class="line">  sock.async_wait(tcp::socket::wait_write, op);</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01346">1346</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a6ab2d02c9fe5c70adc0cd64acee0c505" name="a6ab2d02c9fe5c70adc0cd64acee0c505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab2d02c9fe5c70adc0cd64acee0c505">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the native socket implementation. </p>
<p >This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the underlying socket is put into non-blocking mode and direct system calls may fail with boost::asio::error::would_block (or the equivalent system error).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. If the <code>mode</code> is <code>false</code>, but the current value of <code><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6" title="Gets the non-blocking mode of the socket.">non_blocking()</a></code> is <code>true</code>, this function fails with boost::asio::error::invalid_argument, as the combination does not make sense.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's <code>sendfile</code> system call might be encapsulated: <div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>sendfile_op</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; sock_;</div>
<div class="line">  <span class="keywordtype">int</span> fd_;</div>
<div class="line">  Handler handler_;</div>
<div class="line">  off_t offset_;</div>
<div class="line">  std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function call operator meeting WriteHandler requirements.</span></div>
<div class="line">  <span class="comment">// Used as the handler for the async_write_some operation.</span></div>
<div class="line">  <span class="keywordtype">void</span> operator()(boost::system::error_code ec, std::size_t)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Put the underlying socket into non-blocking mode.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">      <span class="keywordflow">if</span> (!sock_.native_non_blocking())</div>
<div class="line">        sock_.native_non_blocking(<span class="keyword">true</span>, ec);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (;;)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Try the system call.</span></div>
<div class="line">        errno = 0;</div>
<div class="line">        <span class="keywordtype">int</span> n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</div>
<div class="line">        ec = boost::system::error_code(n &lt; 0 ? errno : 0,</div>
<div class="line">            boost::asio::error::get_system_category());</div>
<div class="line">        total_bytes_transferred_ += ec ? 0 : n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Retry operation immediately if interrupted by signal.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::interrupted)</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if we need to run the operation again.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::would_block</div>
<div class="line">            || ec == boost::asio::error::try_again)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// We have to wait for the socket to become ready again.</span></div>
<div class="line">          sock_.async_wait(tcp::socket::wait_write, *<span class="keyword">this</span>);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec || n == 0)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// An error occurred, or we have reached the end of the file.</span></div>
<div class="line">          <span class="comment">// Either way we must exit the loop so we can call the handler.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop around to try calling sendfile again.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass result back to user&#39;s handler.</span></div>
<div class="line">    handler_(ec, total_bytes_transferred_);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_sendfile(tcp::socket&amp; sock, <span class="keywordtype">int</span> fd, Handler h)</div>
<div class="line">{</div>
<div class="line">  sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</div>
<div class="line">  sock.async_wait(tcp::socket::wait_write, op);</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01374">1374</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a6ab2d02c9fe5c70adc0cd64acee0c505" name="a6ab2d02c9fe5c70adc0cd64acee0c505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab2d02c9fe5c70adc0cd64acee0c505">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the native socket implementation. </p>
<p >This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the underlying socket is put into non-blocking mode and direct system calls may fail with boost::asio::error::would_block (or the equivalent system error).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. If the <code>mode</code> is <code>false</code>, but the current value of <code><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6" title="Gets the non-blocking mode of the socket.">non_blocking()</a></code> is <code>true</code>, this function fails with boost::asio::error::invalid_argument, as the combination does not make sense.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's <code>sendfile</code> system call might be encapsulated: <div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>sendfile_op</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; sock_;</div>
<div class="line">  <span class="keywordtype">int</span> fd_;</div>
<div class="line">  Handler handler_;</div>
<div class="line">  off_t offset_;</div>
<div class="line">  std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function call operator meeting WriteHandler requirements.</span></div>
<div class="line">  <span class="comment">// Used as the handler for the async_write_some operation.</span></div>
<div class="line">  <span class="keywordtype">void</span> operator()(boost::system::error_code ec, std::size_t)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Put the underlying socket into non-blocking mode.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">      <span class="keywordflow">if</span> (!sock_.native_non_blocking())</div>
<div class="line">        sock_.native_non_blocking(<span class="keyword">true</span>, ec);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (;;)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Try the system call.</span></div>
<div class="line">        errno = 0;</div>
<div class="line">        <span class="keywordtype">int</span> n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</div>
<div class="line">        ec = boost::system::error_code(n &lt; 0 ? errno : 0,</div>
<div class="line">            boost::asio::error::get_system_category());</div>
<div class="line">        total_bytes_transferred_ += ec ? 0 : n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Retry operation immediately if interrupted by signal.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::interrupted)</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if we need to run the operation again.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::would_block</div>
<div class="line">            || ec == boost::asio::error::try_again)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// We have to wait for the socket to become ready again.</span></div>
<div class="line">          sock_.async_wait(tcp::socket::wait_write, *<span class="keyword">this</span>);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec || n == 0)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// An error occurred, or we have reached the end of the file.</span></div>
<div class="line">          <span class="comment">// Either way we must exit the loop so we can call the handler.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop around to try calling sendfile again.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass result back to user&#39;s handler.</span></div>
<div class="line">    handler_(ec, total_bytes_transferred_);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_sendfile(tcp::socket&amp; sock, <span class="keywordtype">int</span> fd, Handler h)</div>
<div class="line">{</div>
<div class="line">  sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</div>
<div class="line">  sock.async_wait(tcp::socket::wait_write, op);</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01436">1436</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a6ab2d02c9fe5c70adc0cd64acee0c505" name="a6ab2d02c9fe5c70adc0cd64acee0c505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab2d02c9fe5c70adc0cd64acee0c505">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the native socket implementation. </p>
<p >This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the underlying socket is put into non-blocking mode and direct system calls may fail with boost::asio::error::would_block (or the equivalent system error).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. If the <code>mode</code> is <code>false</code>, but the current value of <code><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6" title="Gets the non-blocking mode of the socket.">non_blocking()</a></code> is <code>true</code>, this function fails with boost::asio::error::invalid_argument, as the combination does not make sense.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's <code>sendfile</code> system call might be encapsulated: <div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>sendfile_op</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; sock_;</div>
<div class="line">  <span class="keywordtype">int</span> fd_;</div>
<div class="line">  Handler handler_;</div>
<div class="line">  off_t offset_;</div>
<div class="line">  std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function call operator meeting WriteHandler requirements.</span></div>
<div class="line">  <span class="comment">// Used as the handler for the async_write_some operation.</span></div>
<div class="line">  <span class="keywordtype">void</span> operator()(boost::system::error_code ec, std::size_t)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Put the underlying socket into non-blocking mode.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">      <span class="keywordflow">if</span> (!sock_.native_non_blocking())</div>
<div class="line">        sock_.native_non_blocking(<span class="keyword">true</span>, ec);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (;;)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Try the system call.</span></div>
<div class="line">        errno = 0;</div>
<div class="line">        <span class="keywordtype">int</span> n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</div>
<div class="line">        ec = boost::system::error_code(n &lt; 0 ? errno : 0,</div>
<div class="line">            boost::asio::error::get_system_category());</div>
<div class="line">        total_bytes_transferred_ += ec ? 0 : n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Retry operation immediately if interrupted by signal.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::interrupted)</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if we need to run the operation again.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::would_block</div>
<div class="line">            || ec == boost::asio::error::try_again)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// We have to wait for the socket to become ready again.</span></div>
<div class="line">          sock_.async_wait(tcp::socket::wait_write, *<span class="keyword">this</span>);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec || n == 0)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// An error occurred, or we have reached the end of the file.</span></div>
<div class="line">          <span class="comment">// Either way we must exit the loop so we can call the handler.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop around to try calling sendfile again.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass result back to user&#39;s handler.</span></div>
<div class="line">    handler_(ec, total_bytes_transferred_);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_sendfile(tcp::socket&amp; sock, <span class="keywordtype">int</span> fd, Handler h)</div>
<div class="line">{</div>
<div class="line">  sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</div>
<div class="line">  sock.async_wait(tcp::socket::wait_write, op);</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01436">1436</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a6ab2d02c9fe5c70adc0cd64acee0c505" name="a6ab2d02c9fe5c70adc0cd64acee0c505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab2d02c9fe5c70adc0cd64acee0c505">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the native socket implementation. </p>
<p >This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the underlying socket is put into non-blocking mode and direct system calls may fail with boost::asio::error::would_block (or the equivalent system error).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure. If the <code>mode</code> is <code>false</code>, but the current value of <code><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6" title="Gets the non-blocking mode of the socket.">non_blocking()</a></code> is <code>true</code>, this function fails with boost::asio::error::invalid_argument, as the combination does not make sense.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's <code>sendfile</code> system call might be encapsulated: <div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>sendfile_op</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; sock_;</div>
<div class="line">  <span class="keywordtype">int</span> fd_;</div>
<div class="line">  Handler handler_;</div>
<div class="line">  off_t offset_;</div>
<div class="line">  std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function call operator meeting WriteHandler requirements.</span></div>
<div class="line">  <span class="comment">// Used as the handler for the async_write_some operation.</span></div>
<div class="line">  <span class="keywordtype">void</span> operator()(boost::system::error_code ec, std::size_t)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Put the underlying socket into non-blocking mode.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">      <span class="keywordflow">if</span> (!sock_.native_non_blocking())</div>
<div class="line">        sock_.native_non_blocking(<span class="keyword">true</span>, ec);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (;;)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Try the system call.</span></div>
<div class="line">        errno = 0;</div>
<div class="line">        <span class="keywordtype">int</span> n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</div>
<div class="line">        ec = boost::system::error_code(n &lt; 0 ? errno : 0,</div>
<div class="line">            boost::asio::error::get_system_category());</div>
<div class="line">        total_bytes_transferred_ += ec ? 0 : n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Retry operation immediately if interrupted by signal.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::interrupted)</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if we need to run the operation again.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::would_block</div>
<div class="line">            || ec == boost::asio::error::try_again)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// We have to wait for the socket to become ready again.</span></div>
<div class="line">          sock_.async_wait(tcp::socket::wait_write, *<span class="keyword">this</span>);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec || n == 0)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// An error occurred, or we have reached the end of the file.</span></div>
<div class="line">          <span class="comment">// Either way we must exit the loop so we can call the handler.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop around to try calling sendfile again.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass result back to user&#39;s handler.</span></div>
<div class="line">    handler_(ec, total_bytes_transferred_);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_sendfile(tcp::socket&amp; sock, <span class="keywordtype">int</span> fd, Handler h)</div>
<div class="line">{</div>
<div class="line">  sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</div>
<div class="line">  sock.async_wait(tcp::socket::wait_write, op);</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01436">1436</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a440a334c97758148d69593027ee086a0" name="a440a334c97758148d69593027ee086a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440a334c97758148d69593027ee086a0">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the native socket implementation. </p>
<p >This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the underlying socket is put into non-blocking mode and direct system calls may fail with boost::asio::error::would_block (or the equivalent system error).</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the <code>mode</code> is <code>false</code>, but the current value of <code><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6" title="Gets the non-blocking mode of the socket.">non_blocking()</a></code> is <code>true</code>, this function fails with boost::asio::error::invalid_argument, as the combination does not make sense.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's <code>sendfile</code> system call might be encapsulated: <div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>sendfile_op</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; sock_;</div>
<div class="line">  <span class="keywordtype">int</span> fd_;</div>
<div class="line">  Handler handler_;</div>
<div class="line">  off_t offset_;</div>
<div class="line">  std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function call operator meeting WriteHandler requirements.</span></div>
<div class="line">  <span class="comment">// Used as the handler for the async_write_some operation.</span></div>
<div class="line">  <span class="keywordtype">void</span> operator()(boost::system::error_code ec, std::size_t)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Put the underlying socket into non-blocking mode.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">      <span class="keywordflow">if</span> (!sock_.native_non_blocking())</div>
<div class="line">        sock_.native_non_blocking(<span class="keyword">true</span>, ec);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (;;)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Try the system call.</span></div>
<div class="line">        errno = 0;</div>
<div class="line">        <span class="keywordtype">int</span> n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</div>
<div class="line">        ec = boost::system::error_code(n &lt; 0 ? errno : 0,</div>
<div class="line">            boost::asio::error::get_system_category());</div>
<div class="line">        total_bytes_transferred_ += ec ? 0 : n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Retry operation immediately if interrupted by signal.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::interrupted)</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if we need to run the operation again.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::would_block</div>
<div class="line">            || ec == boost::asio::error::try_again)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// We have to wait for the socket to become ready again.</span></div>
<div class="line">          sock_.async_wait(tcp::socket::wait_write, *<span class="keyword">this</span>);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec || n == 0)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// An error occurred, or we have reached the end of the file.</span></div>
<div class="line">          <span class="comment">// Either way we must exit the loop so we can call the handler.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop around to try calling sendfile again.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass result back to user&#39;s handler.</span></div>
<div class="line">    handler_(ec, total_bytes_transferred_);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_sendfile(tcp::socket&amp; sock, <span class="keywordtype">int</span> fd, Handler h)</div>
<div class="line">{</div>
<div class="line">  sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</div>
<div class="line">  sock.async_wait(tcp::socket::wait_write, op);</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01467">1467</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a440a334c97758148d69593027ee086a0" name="a440a334c97758148d69593027ee086a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440a334c97758148d69593027ee086a0">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the native socket implementation. </p>
<p >This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the underlying socket is put into non-blocking mode and direct system calls may fail with boost::asio::error::would_block (or the equivalent system error).</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the <code>mode</code> is <code>false</code>, but the current value of <code><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6" title="Gets the non-blocking mode of the socket.">non_blocking()</a></code> is <code>true</code>, this function fails with boost::asio::error::invalid_argument, as the combination does not make sense.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's <code>sendfile</code> system call might be encapsulated: <div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>sendfile_op</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; sock_;</div>
<div class="line">  <span class="keywordtype">int</span> fd_;</div>
<div class="line">  Handler handler_;</div>
<div class="line">  off_t offset_;</div>
<div class="line">  std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function call operator meeting WriteHandler requirements.</span></div>
<div class="line">  <span class="comment">// Used as the handler for the async_write_some operation.</span></div>
<div class="line">  <span class="keywordtype">void</span> operator()(boost::system::error_code ec, std::size_t)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Put the underlying socket into non-blocking mode.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">      <span class="keywordflow">if</span> (!sock_.native_non_blocking())</div>
<div class="line">        sock_.native_non_blocking(<span class="keyword">true</span>, ec);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (;;)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Try the system call.</span></div>
<div class="line">        errno = 0;</div>
<div class="line">        <span class="keywordtype">int</span> n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</div>
<div class="line">        ec = boost::system::error_code(n &lt; 0 ? errno : 0,</div>
<div class="line">            boost::asio::error::get_system_category());</div>
<div class="line">        total_bytes_transferred_ += ec ? 0 : n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Retry operation immediately if interrupted by signal.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::interrupted)</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if we need to run the operation again.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::would_block</div>
<div class="line">            || ec == boost::asio::error::try_again)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// We have to wait for the socket to become ready again.</span></div>
<div class="line">          sock_.async_wait(tcp::socket::wait_write, *<span class="keyword">this</span>);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec || n == 0)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// An error occurred, or we have reached the end of the file.</span></div>
<div class="line">          <span class="comment">// Either way we must exit the loop so we can call the handler.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop around to try calling sendfile again.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass result back to user&#39;s handler.</span></div>
<div class="line">    handler_(ec, total_bytes_transferred_);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_sendfile(tcp::socket&amp; sock, <span class="keywordtype">int</span> fd, Handler h)</div>
<div class="line">{</div>
<div class="line">  sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</div>
<div class="line">  sock.async_wait(tcp::socket::wait_write, op);</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01529">1529</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a440a334c97758148d69593027ee086a0" name="a440a334c97758148d69593027ee086a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440a334c97758148d69593027ee086a0">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the native socket implementation. </p>
<p >This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the underlying socket is put into non-blocking mode and direct system calls may fail with boost::asio::error::would_block (or the equivalent system error).</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the <code>mode</code> is <code>false</code>, but the current value of <code><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6" title="Gets the non-blocking mode of the socket.">non_blocking()</a></code> is <code>true</code>, this function fails with boost::asio::error::invalid_argument, as the combination does not make sense.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's <code>sendfile</code> system call might be encapsulated: <div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>sendfile_op</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; sock_;</div>
<div class="line">  <span class="keywordtype">int</span> fd_;</div>
<div class="line">  Handler handler_;</div>
<div class="line">  off_t offset_;</div>
<div class="line">  std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function call operator meeting WriteHandler requirements.</span></div>
<div class="line">  <span class="comment">// Used as the handler for the async_write_some operation.</span></div>
<div class="line">  <span class="keywordtype">void</span> operator()(boost::system::error_code ec, std::size_t)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Put the underlying socket into non-blocking mode.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">      <span class="keywordflow">if</span> (!sock_.native_non_blocking())</div>
<div class="line">        sock_.native_non_blocking(<span class="keyword">true</span>, ec);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (;;)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Try the system call.</span></div>
<div class="line">        errno = 0;</div>
<div class="line">        <span class="keywordtype">int</span> n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</div>
<div class="line">        ec = boost::system::error_code(n &lt; 0 ? errno : 0,</div>
<div class="line">            boost::asio::error::get_system_category());</div>
<div class="line">        total_bytes_transferred_ += ec ? 0 : n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Retry operation immediately if interrupted by signal.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::interrupted)</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if we need to run the operation again.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::would_block</div>
<div class="line">            || ec == boost::asio::error::try_again)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// We have to wait for the socket to become ready again.</span></div>
<div class="line">          sock_.async_wait(tcp::socket::wait_write, *<span class="keyword">this</span>);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec || n == 0)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// An error occurred, or we have reached the end of the file.</span></div>
<div class="line">          <span class="comment">// Either way we must exit the loop so we can call the handler.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop around to try calling sendfile again.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass result back to user&#39;s handler.</span></div>
<div class="line">    handler_(ec, total_bytes_transferred_);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_sendfile(tcp::socket&amp; sock, <span class="keywordtype">int</span> fd, Handler h)</div>
<div class="line">{</div>
<div class="line">  sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</div>
<div class="line">  sock.async_wait(tcp::socket::wait_write, op);</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01529">1529</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a440a334c97758148d69593027ee086a0" name="a440a334c97758148d69593027ee086a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440a334c97758148d69593027ee086a0">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the native socket implementation. </p>
<p >This function is used to modify the non-blocking mode of the underlying native socket. It has no effect on the behaviour of the socket object's synchronous operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the underlying socket is put into non-blocking mode and direct system calls may fail with boost::asio::error::would_block (or the equivalent system error).</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the <code>mode</code> is <code>false</code>, but the current value of <code><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5583879f72ebbabf7cba6db1d53e05b6" title="Gets the non-blocking mode of the socket.">non_blocking()</a></code> is <code>true</code>, this function fails with boost::asio::error::invalid_argument, as the combination does not make sense.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>This function is intended to allow the encapsulation of arbitrary non-blocking system calls as asynchronous operations, in a way that is transparent to the user of the socket object. The following example illustrates how Linux's <code>sendfile</code> system call might be encapsulated: <div class="fragment"><div class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keyword">struct </span>sendfile_op</div>
<div class="line">{</div>
<div class="line">  tcp::socket&amp; sock_;</div>
<div class="line">  <span class="keywordtype">int</span> fd_;</div>
<div class="line">  Handler handler_;</div>
<div class="line">  off_t offset_;</div>
<div class="line">  std::size_t total_bytes_transferred_;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function call operator meeting WriteHandler requirements.</span></div>
<div class="line">  <span class="comment">// Used as the handler for the async_write_some operation.</span></div>
<div class="line">  <span class="keywordtype">void</span> operator()(boost::system::error_code ec, std::size_t)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Put the underlying socket into non-blocking mode.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">      <span class="keywordflow">if</span> (!sock_.native_non_blocking())</div>
<div class="line">        sock_.native_non_blocking(<span class="keyword">true</span>, ec);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!ec)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">for</span> (;;)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Try the system call.</span></div>
<div class="line">        errno = 0;</div>
<div class="line">        <span class="keywordtype">int</span> n = ::sendfile(sock_.native_handle(), fd_, &amp;offset_, 65536);</div>
<div class="line">        ec = boost::system::error_code(n &lt; 0 ? errno : 0,</div>
<div class="line">            boost::asio::error::get_system_category());</div>
<div class="line">        total_bytes_transferred_ += ec ? 0 : n;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Retry operation immediately if interrupted by signal.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::interrupted)</div>
<div class="line">          <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Check if we need to run the operation again.</span></div>
<div class="line">        <span class="keywordflow">if</span> (ec == boost::asio::error::would_block</div>
<div class="line">            || ec == boost::asio::error::try_again)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// We have to wait for the socket to become ready again.</span></div>
<div class="line">          sock_.async_wait(tcp::socket::wait_write, *<span class="keyword">this</span>);</div>
<div class="line">          <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (ec || n == 0)</div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// An error occurred, or we have reached the end of the file.</span></div>
<div class="line">          <span class="comment">// Either way we must exit the loop so we can call the handler.</span></div>
<div class="line">          <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop around to try calling sendfile again.</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pass result back to user&#39;s handler.</span></div>
<div class="line">    handler_(ec, total_bytes_transferred_);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Handler&gt;</div>
<div class="line"><span class="keywordtype">void</span> async_sendfile(tcp::socket&amp; sock, <span class="keywordtype">int</span> fd, Handler h)</div>
<div class="line">{</div>
<div class="line">  sendfile_op&lt;Handler&gt; op = { sock, fd, h, 0, 0 };</div>
<div class="line">  sock.async_wait(tcp::socket::wait_write, op);</div>
<div class="line">} </div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01529">1529</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a5583879f72ebbabf7cba6db1d53e05b6" name="a5583879f72ebbabf7cba6db1d53e05b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5583879f72ebbabf7cba6db1d53e05b6">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the non-blocking mode of the socket. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the socket's synchronous operations will fail with boost::asio::error::would_block if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error boost::asio::error::would_block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01155">1155</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a5583879f72ebbabf7cba6db1d53e05b6" name="a5583879f72ebbabf7cba6db1d53e05b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5583879f72ebbabf7cba6db1d53e05b6">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the non-blocking mode of the socket. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the socket's synchronous operations will fail with boost::asio::error::would_block if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error boost::asio::error::would_block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01217">1217</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a5583879f72ebbabf7cba6db1d53e05b6" name="a5583879f72ebbabf7cba6db1d53e05b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5583879f72ebbabf7cba6db1d53e05b6">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the non-blocking mode of the socket. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the socket's synchronous operations will fail with boost::asio::error::would_block if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error boost::asio::error::would_block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01217">1217</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a5583879f72ebbabf7cba6db1d53e05b6" name="a5583879f72ebbabf7cba6db1d53e05b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5583879f72ebbabf7cba6db1d53e05b6">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the non-blocking mode of the socket. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the socket's synchronous operations will fail with boost::asio::error::would_block if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error boost::asio::error::would_block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01217">1217</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab8cb97246819ca03b004303a36215a22" name="ab8cb97246819ca03b004303a36215a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cb97246819ca03b004303a36215a22">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the socket's synchronous operations will fail with boost::asio::error::would_block if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error boost::asio::error::would_block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01173">1173</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab8cb97246819ca03b004303a36215a22" name="ab8cb97246819ca03b004303a36215a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cb97246819ca03b004303a36215a22">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the socket's synchronous operations will fail with boost::asio::error::would_block if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error boost::asio::error::would_block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01235">1235</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab8cb97246819ca03b004303a36215a22" name="ab8cb97246819ca03b004303a36215a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cb97246819ca03b004303a36215a22">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the socket's synchronous operations will fail with boost::asio::error::would_block if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error boost::asio::error::would_block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01235">1235</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab8cb97246819ca03b004303a36215a22" name="ab8cb97246819ca03b004303a36215a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cb97246819ca03b004303a36215a22">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the socket's synchronous operations will fail with boost::asio::error::would_block if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error boost::asio::error::would_block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01235">1235</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="af847fa0d78fc4c63edfe85e0da0fa416" name="af847fa0d78fc4c63edfe85e0da0fa416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af847fa0d78fc4c63edfe85e0da0fa416">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the socket's synchronous operations will fail with boost::asio::error::would_block if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error boost::asio::error::would_block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01193">1193</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="af847fa0d78fc4c63edfe85e0da0fa416" name="af847fa0d78fc4c63edfe85e0da0fa416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af847fa0d78fc4c63edfe85e0da0fa416">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the socket's synchronous operations will fail with boost::asio::error::would_block if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error boost::asio::error::would_block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01255">1255</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="af847fa0d78fc4c63edfe85e0da0fa416" name="af847fa0d78fc4c63edfe85e0da0fa416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af847fa0d78fc4c63edfe85e0da0fa416">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the socket's synchronous operations will fail with boost::asio::error::would_block if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error boost::asio::error::would_block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01255">1255</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="af847fa0d78fc4c63edfe85e0da0fa416" name="af847fa0d78fc4c63edfe85e0da0fa416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af847fa0d78fc4c63edfe85e0da0fa416">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the socket's synchronous operations will fail with boost::asio::error::would_block if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error boost::asio::error::would_block. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01255">1255</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a5b206ea012bc0a77a9c71d139699083f" name="a5b206ea012bc0a77a9c71d139699083f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b206ea012bc0a77a9c71d139699083f">&#9670;&nbsp;</a></span>open() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the socket using the specified protocol. </p>
<p >This function opens the socket so that it will use the specified protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>An object specifying which protocol is to be used.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00354">354</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a5b206ea012bc0a77a9c71d139699083f" name="a5b206ea012bc0a77a9c71d139699083f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b206ea012bc0a77a9c71d139699083f">&#9670;&nbsp;</a></span>open() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the socket using the specified protocol. </p>
<p >This function opens the socket so that it will use the specified protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>An object specifying which protocol is to be used.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00443">443</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a5b206ea012bc0a77a9c71d139699083f" name="a5b206ea012bc0a77a9c71d139699083f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b206ea012bc0a77a9c71d139699083f">&#9670;&nbsp;</a></span>open() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the socket using the specified protocol. </p>
<p >This function opens the socket so that it will use the specified protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>An object specifying which protocol is to be used.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00443">443</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a5b206ea012bc0a77a9c71d139699083f" name="a5b206ea012bc0a77a9c71d139699083f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b206ea012bc0a77a9c71d139699083f">&#9670;&nbsp;</a></span>open() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the socket using the specified protocol. </p>
<p >This function opens the socket so that it will use the specified protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>An object specifying which protocol is to be used.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4(), ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00443">443</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a26576c8e6d36e76747d1b780b6196b37" name="a26576c8e6d36e76747d1b780b6196b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26576c8e6d36e76747d1b780b6196b37">&#9670;&nbsp;</a></span>open() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em> = <code><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the socket using the specified protocol. </p>
<p >This function opens the socket so that it will use the specified protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4());</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00328">328</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a26576c8e6d36e76747d1b780b6196b37" name="a26576c8e6d36e76747d1b780b6196b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26576c8e6d36e76747d1b780b6196b37">&#9670;&nbsp;</a></span>open() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em> = <code><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the socket using the specified protocol. </p>
<p >This function opens the socket so that it will use the specified protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4());</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00417">417</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a26576c8e6d36e76747d1b780b6196b37" name="a26576c8e6d36e76747d1b780b6196b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26576c8e6d36e76747d1b780b6196b37">&#9670;&nbsp;</a></span>open() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em> = <code><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the socket using the specified protocol. </p>
<p >This function opens the socket so that it will use the specified protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4());</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00417">417</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a26576c8e6d36e76747d1b780b6196b37" name="a26576c8e6d36e76747d1b780b6196b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26576c8e6d36e76747d1b780b6196b37">&#9670;&nbsp;</a></span>open() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em> = <code><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a5989efa6b723759fc9c2f1597d2dfa7f">protocol_type</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open the socket using the specified protocol. </p>
<p >This function opens the socket so that it will use the specified protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">socket.open(boost::asio::ip::tcp::v4());</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00417">417</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a227b2204377ed42af6a9a6f4ca413a72" name="a227b2204377ed42af6a9a6f4ca413a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227b2204377ed42af6a9a6f4ca413a72">&#9670;&nbsp;</a></span>release() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release ownership of the underlying native socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error. Ownership of the native socket is then transferred to the caller.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is unsupported on Windows versions prior to Windows 8.1, and will fail with boost::asio::error::operation_not_supported on these platforms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00472">472</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a227b2204377ed42af6a9a6f4ca413a72" name="a227b2204377ed42af6a9a6f4ca413a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227b2204377ed42af6a9a6f4ca413a72">&#9670;&nbsp;</a></span>release() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release ownership of the underlying native socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error. Ownership of the native socket is then transferred to the caller.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is unsupported on Windows versions prior to Windows 8.1, and will fail with boost::asio::error::operation_not_supported on these platforms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00561">561</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a227b2204377ed42af6a9a6f4ca413a72" name="a227b2204377ed42af6a9a6f4ca413a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227b2204377ed42af6a9a6f4ca413a72">&#9670;&nbsp;</a></span>release() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release ownership of the underlying native socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error. Ownership of the native socket is then transferred to the caller.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is unsupported on Windows versions prior to Windows 8.1, and will fail with boost::asio::error::operation_not_supported on these platforms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00561">561</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a227b2204377ed42af6a9a6f4ca413a72" name="a227b2204377ed42af6a9a6f4ca413a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227b2204377ed42af6a9a6f4ca413a72">&#9670;&nbsp;</a></span>release() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release ownership of the underlying native socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error. Ownership of the native socket is then transferred to the caller.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is unsupported on Windows versions prior to Windows 8.1, and will fail with boost::asio::error::operation_not_supported on these platforms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00561">561</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aea481ad3c0b5ec252c560aa032a20a67" name="aea481ad3c0b5ec252c560aa032a20a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea481ad3c0b5ec252c560aa032a20a67">&#9670;&nbsp;</a></span>release() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::release </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release ownership of the underlying native socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error. Ownership of the native socket is then transferred to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is unsupported on Windows versions prior to Windows 8.1, and will fail with boost::asio::error::operation_not_supported on these platforms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00500">500</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aea481ad3c0b5ec252c560aa032a20a67" name="aea481ad3c0b5ec252c560aa032a20a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea481ad3c0b5ec252c560aa032a20a67">&#9670;&nbsp;</a></span>release() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::release </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release ownership of the underlying native socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error. Ownership of the native socket is then transferred to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is unsupported on Windows versions prior to Windows 8.1, and will fail with boost::asio::error::operation_not_supported on these platforms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00589">589</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aea481ad3c0b5ec252c560aa032a20a67" name="aea481ad3c0b5ec252c560aa032a20a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea481ad3c0b5ec252c560aa032a20a67">&#9670;&nbsp;</a></span>release() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::release </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release ownership of the underlying native socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error. Ownership of the native socket is then transferred to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is unsupported on Windows versions prior to Windows 8.1, and will fail with boost::asio::error::operation_not_supported on these platforms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00589">589</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aea481ad3c0b5ec252c560aa032a20a67" name="aea481ad3c0b5ec252c560aa032a20a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea481ad3c0b5ec252c560aa032a20a67">&#9670;&nbsp;</a></span>release() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#a7745ea4769db54c740f43a0c6a17dec6">native_handle_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::release </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release ownership of the underlying native socket. </p>
<p >This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the boost::asio::error::operation_aborted error. Ownership of the native socket is then transferred to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is unsupported on Windows versions prior to Windows 8.1, and will fail with boost::asio::error::operation_not_supported on these platforms. </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00589">589</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="afe814bdd7411657702a1b53e833b456a" name="afe814bdd7411657702a1b53e833b456a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe814bdd7411657702a1b53e833b456a">&#9670;&nbsp;</a></span>remote_endpoint() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::remote_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remote endpoint of the socket. </p>
<p >This function is used to obtain the remote endpoint of the socket.</p>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the remote endpoint of the socket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01540">1540</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="afe814bdd7411657702a1b53e833b456a" name="afe814bdd7411657702a1b53e833b456a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe814bdd7411657702a1b53e833b456a">&#9670;&nbsp;</a></span>remote_endpoint() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::remote_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remote endpoint of the socket. </p>
<p >This function is used to obtain the remote endpoint of the socket.</p>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the remote endpoint of the socket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01602">1602</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="afe814bdd7411657702a1b53e833b456a" name="afe814bdd7411657702a1b53e833b456a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe814bdd7411657702a1b53e833b456a">&#9670;&nbsp;</a></span>remote_endpoint() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::remote_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remote endpoint of the socket. </p>
<p >This function is used to obtain the remote endpoint of the socket.</p>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the remote endpoint of the socket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01602">1602</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="afe814bdd7411657702a1b53e833b456a" name="afe814bdd7411657702a1b53e833b456a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe814bdd7411657702a1b53e833b456a">&#9670;&nbsp;</a></span>remote_endpoint() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::remote_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remote endpoint of the socket. </p>
<p >This function is used to obtain the remote endpoint of the socket.</p>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the remote endpoint of the socket.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint();</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01602">1602</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac098a6653e8f75b97ac5d43b13032db9" name="ac098a6653e8f75b97ac5d43b13032db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac098a6653e8f75b97ac5d43b13032db9">&#9670;&nbsp;</a></span>remote_endpoint() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::remote_endpoint </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remote endpoint of the socket. </p>
<p >This function is used to obtain the remote endpoint of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01570">1570</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac098a6653e8f75b97ac5d43b13032db9" name="ac098a6653e8f75b97ac5d43b13032db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac098a6653e8f75b97ac5d43b13032db9">&#9670;&nbsp;</a></span>remote_endpoint() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::remote_endpoint </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remote endpoint of the socket. </p>
<p >This function is used to obtain the remote endpoint of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01632">1632</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac098a6653e8f75b97ac5d43b13032db9" name="ac098a6653e8f75b97ac5d43b13032db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac098a6653e8f75b97ac5d43b13032db9">&#9670;&nbsp;</a></span>remote_endpoint() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::remote_endpoint </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remote endpoint of the socket. </p>
<p >This function is used to obtain the remote endpoint of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01632">1632</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ac098a6653e8f75b97ac5d43b13032db9" name="ac098a6653e8f75b97ac5d43b13032db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac098a6653e8f75b97ac5d43b13032db9">&#9670;&nbsp;</a></span>remote_endpoint() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html#aab9a01a2659abf8a5acafa431763772d">endpoint_type</a> <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::remote_endpoint </td>
          <td>(</td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the remote endpoint of the socket. </p>
<p >This function is used to obtain the remote endpoint of the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the remote endpoint of the socket. Returns a default-constructed endpoint object if an error occurred.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">boost::asio::ip::tcp::endpoint endpoint = socket.remote_endpoint(ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01632">1632</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aa8a7300fb93369d191e10c30e9910cb7" name="aa8a7300fb93369d191e10c30e9910cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a7300fb93369d191e10c30e9910cb7">&#9670;&nbsp;</a></span>set_option() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename SettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::set_option </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an option on the socket. </p>
<p >This function is used to set an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The new option value to be set on the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>SettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Setting the IPPROTO_TCP/TCP_NODELAY option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::no_delay option(<span class="keyword">true</span>);</div>
<div class="line">socket.set_option(option);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00934">934</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aa8a7300fb93369d191e10c30e9910cb7" name="aa8a7300fb93369d191e10c30e9910cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a7300fb93369d191e10c30e9910cb7">&#9670;&nbsp;</a></span>set_option() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename SettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::set_option </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an option on the socket. </p>
<p >This function is used to set an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The new option value to be set on the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>SettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Setting the IPPROTO_TCP/TCP_NODELAY option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::no_delay option(<span class="keyword">true</span>);</div>
<div class="line">socket.set_option(option);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00996">996</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aa8a7300fb93369d191e10c30e9910cb7" name="aa8a7300fb93369d191e10c30e9910cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a7300fb93369d191e10c30e9910cb7">&#9670;&nbsp;</a></span>set_option() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename SettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::set_option </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an option on the socket. </p>
<p >This function is used to set an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The new option value to be set on the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>SettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Setting the IPPROTO_TCP/TCP_NODELAY option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::no_delay option(<span class="keyword">true</span>);</div>
<div class="line">socket.set_option(option);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00996">996</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aa8a7300fb93369d191e10c30e9910cb7" name="aa8a7300fb93369d191e10c30e9910cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a7300fb93369d191e10c30e9910cb7">&#9670;&nbsp;</a></span>set_option() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename SettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::set_option </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an option on the socket. </p>
<p >This function is used to set an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The new option value to be set on the socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>SettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Setting the IPPROTO_TCP/TCP_NODELAY option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::no_delay option(<span class="keyword">true</span>);</div>
<div class="line">socket.set_option(option);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00996">996</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aec41185f85b3ead8586d4158ab4784d1" name="aec41185f85b3ead8586d4158ab4784d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec41185f85b3ead8586d4158ab4784d1">&#9670;&nbsp;</a></span>set_option() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename SettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::set_option </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an option on the socket. </p>
<p >This function is used to set an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The new option value to be set on the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>SettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Setting the IPPROTO_TCP/TCP_NODELAY option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::no_delay option(<span class="keyword">true</span>);</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.set_option(option, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l00981">981</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aec41185f85b3ead8586d4158ab4784d1" name="aec41185f85b3ead8586d4158ab4784d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec41185f85b3ead8586d4158ab4784d1">&#9670;&nbsp;</a></span>set_option() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename SettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::set_option </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an option on the socket. </p>
<p >This function is used to set an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The new option value to be set on the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>SettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Setting the IPPROTO_TCP/TCP_NODELAY option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::no_delay option(<span class="keyword">true</span>);</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.set_option(option, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01043">1043</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aec41185f85b3ead8586d4158ab4784d1" name="aec41185f85b3ead8586d4158ab4784d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec41185f85b3ead8586d4158ab4784d1">&#9670;&nbsp;</a></span>set_option() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename SettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::set_option </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an option on the socket. </p>
<p >This function is used to set an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The new option value to be set on the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>SettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Setting the IPPROTO_TCP/TCP_NODELAY option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::no_delay option(<span class="keyword">true</span>);</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.set_option(option, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01043">1043</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aec41185f85b3ead8586d4158ab4784d1" name="aec41185f85b3ead8586d4158ab4784d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec41185f85b3ead8586d4158ab4784d1">&#9670;&nbsp;</a></span>set_option() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<div class="memtemplate">
template&lt;typename SettableSocketOption &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::set_option </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an option on the socket. </p>
<p >This function is used to set an option on the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The new option value to be set on the socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>SettableSocketOption <br  />
boost::asio::socket_base::broadcast <br  />
boost::asio::socket_base::do_not_route <br  />
boost::asio::socket_base::keep_alive <br  />
boost::asio::socket_base::linger <br  />
boost::asio::socket_base::receive_buffer_size <br  />
boost::asio::socket_base::receive_low_watermark <br  />
boost::asio::socket_base::reuse_address <br  />
boost::asio::socket_base::send_buffer_size <br  />
boost::asio::socket_base::send_low_watermark <br  />
boost::asio::ip::multicast::join_group <br  />
boost::asio::ip::multicast::leave_group <br  />
boost::asio::ip::multicast::enable_loopback <br  />
boost::asio::ip::multicast::outbound_interface <br  />
boost::asio::ip::multicast::hops <br  />
boost::asio::ip::tcp::no_delay</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Setting the IPPROTO_TCP/TCP_NODELAY option: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::asio::ip::tcp::no_delay option(<span class="keyword">true</span>);</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.set_option(option, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01043">1043</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a3b63df8c121779b9397f34ba04666a36" name="a3b63df8c121779b9397f34ba04666a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b63df8c121779b9397f34ba04666a36">&#9670;&nbsp;</a></span>shutdown() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype">shutdown_type&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable sends or receives on the socket. </p>
<p >This function is used to disable send operations, receive operations, or both.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Determines what types of operation will no longer be allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Shutting down the send side of the socket: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01592">1592</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a3b63df8c121779b9397f34ba04666a36" name="a3b63df8c121779b9397f34ba04666a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b63df8c121779b9397f34ba04666a36">&#9670;&nbsp;</a></span>shutdown() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype">shutdown_type&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable sends or receives on the socket. </p>
<p >This function is used to disable send operations, receive operations, or both.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Determines what types of operation will no longer be allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Shutting down the send side of the socket: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01654">1654</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a3b63df8c121779b9397f34ba04666a36" name="a3b63df8c121779b9397f34ba04666a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b63df8c121779b9397f34ba04666a36">&#9670;&nbsp;</a></span>shutdown() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype">shutdown_type&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable sends or receives on the socket. </p>
<p >This function is used to disable send operations, receive operations, or both.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Determines what types of operation will no longer be allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Shutting down the send side of the socket: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01654">1654</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a3b63df8c121779b9397f34ba04666a36" name="a3b63df8c121779b9397f34ba04666a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b63df8c121779b9397f34ba04666a36">&#9670;&nbsp;</a></span>shutdown() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype">shutdown_type&#160;</td>
          <td class="paramname"><em>what</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable sends or receives on the socket. </p>
<p >This function is used to disable send operations, receive operations, or both.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Determines what types of operation will no longer be allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">boost::system::system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Shutting down the send side of the socket: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01654">1654</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab8299c1f15b32b3f43882eb00aa7ba57" name="ab8299c1f15b32b3f43882eb00aa7ba57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8299c1f15b32b3f43882eb00aa7ba57">&#9670;&nbsp;</a></span>shutdown() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype">shutdown_type&#160;</td>
          <td class="paramname"><em>what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable sends or receives on the socket. </p>
<p >This function is used to disable send operations, receive operations, or both.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Determines what types of operation will no longer be allowed.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Shutting down the send side of the socket: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01621">1621</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab8299c1f15b32b3f43882eb00aa7ba57" name="ab8299c1f15b32b3f43882eb00aa7ba57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8299c1f15b32b3f43882eb00aa7ba57">&#9670;&nbsp;</a></span>shutdown() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype">shutdown_type&#160;</td>
          <td class="paramname"><em>what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable sends or receives on the socket. </p>
<p >This function is used to disable send operations, receive operations, or both.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Determines what types of operation will no longer be allowed.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Shutting down the send side of the socket: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01683">1683</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab8299c1f15b32b3f43882eb00aa7ba57" name="ab8299c1f15b32b3f43882eb00aa7ba57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8299c1f15b32b3f43882eb00aa7ba57">&#9670;&nbsp;</a></span>shutdown() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype">shutdown_type&#160;</td>
          <td class="paramname"><em>what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable sends or receives on the socket. </p>
<p >This function is used to disable send operations, receive operations, or both.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Determines what types of operation will no longer be allowed.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Shutting down the send side of the socket: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01683">1683</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="ab8299c1f15b32b3f43882eb00aa7ba57" name="ab8299c1f15b32b3f43882eb00aa7ba57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8299c1f15b32b3f43882eb00aa7ba57">&#9670;&nbsp;</a></span>shutdown() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype">shutdown_type&#160;</td>
          <td class="paramname"><em>what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable sends or receives on the socket. </p>
<p >This function is used to disable send operations, receive operations, or both.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>Determines what types of operation will no longer be allowed.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Shutting down the send side of the socket: <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.shutdown(boost::asio::ip::tcp::socket::shutdown_send, ec);</div>
<div class="line"><span class="keywordflow">if</span> (ec)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// An error occurred.</span></div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01683">1683</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0fe4c776eafd6ae48e36cc1a39f46f86" name="a0fe4c776eafd6ae48e36cc1a39f46f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe4c776eafd6ae48e36cc1a39f46f86">&#9670;&nbsp;</a></span>wait() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">wait_type&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Wait for the socket to become ready to read, ready to write, or to have pending error conditions. This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired socket state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Waiting for a socket to become readable. <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">socket.wait(boost::asio::ip::tcp::socket::wait_read);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01644">1644</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0fe4c776eafd6ae48e36cc1a39f46f86" name="a0fe4c776eafd6ae48e36cc1a39f46f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe4c776eafd6ae48e36cc1a39f46f86">&#9670;&nbsp;</a></span>wait() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">wait_type&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Wait for the socket to become ready to read, ready to write, or to have pending error conditions. This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired socket state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Waiting for a socket to become readable. <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">socket.wait(boost::asio::ip::tcp::socket::wait_read);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01706">1706</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0fe4c776eafd6ae48e36cc1a39f46f86" name="a0fe4c776eafd6ae48e36cc1a39f46f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe4c776eafd6ae48e36cc1a39f46f86">&#9670;&nbsp;</a></span>wait() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">wait_type&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Wait for the socket to become ready to read, ready to write, or to have pending error conditions. This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired socket state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Waiting for a socket to become readable. <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">socket.wait(boost::asio::ip::tcp::socket::wait_read);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01706">1706</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="a0fe4c776eafd6ae48e36cc1a39f46f86" name="a0fe4c776eafd6ae48e36cc1a39f46f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe4c776eafd6ae48e36cc1a39f46f86">&#9670;&nbsp;</a></span>wait() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">wait_type&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Wait for the socket to become ready to read, ready to write, or to have pending error conditions. This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired socket state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Waiting for a socket to become readable. <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">socket.wait(boost::asio::ip::tcp::socket::wait_read);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01706">1706</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aa47272c53e40f0a466ec2901d078f054" name="aa47272c53e40f0a466ec2901d078f054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47272c53e40f0a466ec2901d078f054">&#9670;&nbsp;</a></span>wait() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">wait_type&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Wait for the socket to become ready to read, ready to write, or to have pending error conditions. This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired socket state.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Waiting for a socket to become readable. <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(io_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01670">1670</a> of file <a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aa47272c53e40f0a466ec2901d078f054" name="aa47272c53e40f0a466ec2901d078f054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47272c53e40f0a466ec2901d078f054">&#9670;&nbsp;</a></span>wait() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">wait_type&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Wait for the socket to become ready to read, ready to write, or to have pending error conditions. This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired socket state.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Waiting for a socket to become readable. <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01732">1732</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aa47272c53e40f0a466ec2901d078f054" name="aa47272c53e40f0a466ec2901d078f054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47272c53e40f0a466ec2901d078f054">&#9670;&nbsp;</a></span>wait() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">wait_type&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Wait for the socket to become ready to read, ready to write, or to have pending error conditions. This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired socket state.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Waiting for a socket to become readable. <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01732">1732</a> of file <a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<a id="aa47272c53e40f0a466ec2901d078f054" name="aa47272c53e40f0a466ec2901d078f054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47272c53e40f0a466ec2901d078f054">&#9670;&nbsp;</a></span>wait() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BOOST_ASIO_SYNC_OP_VOID <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::wait </td>
          <td>(</td>
          <td class="paramtype">wait_type&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Wait for the socket to become ready to read, ready to write, or to have pending error conditions. This function is used to perform a blocking wait for a socket to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired socket state.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Waiting for a socket to become readable. <div class="fragment"><div class="line">boost::asio::ip::tcp::socket socket(my_context);</div>
<div class="line">...</div>
<div class="line">boost::system::error_code ec;</div>
<div class="line">socket.wait(boost::asio::ip::tcp::socket::wait_read, ec);</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01732">1732</a> of file <a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a85ac7721870f90e9de4f0fcd2b8e6c44" name="a85ac7721870f90e9de4f0fcd2b8e6c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ac7721870f90e9de4f0fcd2b8e6c44">&#9670;&nbsp;</a></span>impl_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol BOOST_ASIO_SVC_TPARAM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::io_object_impl&lt; <a class="el" href="classboost_1_1asio_1_1detail_1_1reactive__socket__service__ext.html">detail::reactive_socket_service_ext</a>&lt; Protocol &gt;, Executor &gt; <a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">boost::asio::basic_socket_ext</a>&lt; BOOST_ASIO_SVC_TPARAM &gt;::impl_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html#l01801">1801</a> of file <a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/kali/projects/vsomeip/implementation/helper/1.66/boost/asio/<a class="el" href="1_866_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a></li>
<li>/home/kali/projects/vsomeip/implementation/helper/1.70/boost/asio/<a class="el" href="1_870_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a></li>
<li>/home/kali/projects/vsomeip/implementation/helper/1.74/boost/asio/<a class="el" href="1_874_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a></li>
<li>/home/kali/projects/vsomeip/implementation/helper/1.76/boost/asio/<a class="el" href="1_876_2boost_2asio_2basic__socket__ext_8hpp_source.html">basic_socket_ext.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1asio.html">asio</a></li><li class="navelem"><a class="el" href="classboost_1_1asio_1_1basic__socket__ext.html">basic_socket_ext</a></li>
    <li class="footer">Generated on Fri Aug 5 2022 10:49:20 for vsomeip-3.1.20 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
